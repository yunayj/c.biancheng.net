<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<!-- 启用Chromium高速渲染模式 -->
<meta name="renderer" content="webkit" />
<meta name="force-rendering" content="webkit"/>
<!-- 禁止百度转码 -->
<meta name="applicable-device" content="pc,mobile" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<!-- 禁止识别电话号码 -->
<meta name="format-detection" content="telephone=no" />

<link rel="shortcut icon" href="../favicon_3.ico" />
<link href="../templets/new/style/common_2.css" rel="stylesheet" />
<title>Python操作SQLite数据库（非常详细）</title>
<meta name="description" content="SQLite 是一款轻量型的数据库，是遵守 ACID（atomicity, consistency, isolation, durability，原子性、一致性、隔离性、持久性）的关系数据库管理系统，它的设计目标是嵌入式，目前已经有很多嵌" />
</head>
<body>
<div id="topbar" class="clearfix">
	<ul id="product-type" class="left">
		<li>
			<a href="../m_biancheng_default_2.html"><span class="iconfont iconfont-home"></span>首页</a>
		</li>
		<li class="active">
			<a href="../sitemap/sitemap_2.html" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
		</li>
		<li>
			<a href="../fudao_biancheng_default.html" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
		</li>
		<li>
			<a href="niz69i_5.html" target="_blank"><span class="iconfont iconfont-chip"></span>嵌入式学习路线</a>
		</li>
		<!-- <li>
			<a href="https://www.54benniao.com/c_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-c-course"></span>C语言高级课程</a>
		</li>
		<li>
			<a href="https://www.54benniao.com/java_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-java-course"></span>Java高级课程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/q2a/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-q2a"></span>一对一答疑</a>
		</li> -->
	</ul>
</div>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="../m_biancheng_default_2.html">
		<img height="26" src="../templets/new/images/logo_2.png" alt="C语言中文网" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li class="wap-yes"><a href="../m_biancheng_default_2.html">首页</a></li>
		<li><a href="../c/c_4.html">C语言教程</a></li>
		<li><a href="../cplus/cplus_2.html">C++教程</a></li>
		<li><a href="../python/python_2.html">Python教程</a></li>
		<li><a href="../java/java_2.html">Java教程</a></li>
		<li><a href="../linux_tutorial/linux_tutorial_2.html">Linux入门</a></li>
		<li><a href="../sitemap/sitemap_2.html" title="网站地图">更多&gt;&gt;</a></li>
	</ul>
	<a href="http://vip.biancheng.net/?from=topbar" class="user-info iconfont iconfont-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main-no-course" class="clearfix">
	<div class="arc-info">
		<span class="position"><span class="iconfont iconfont-home2"></span> <a href="../m_biancheng_default_2.html">首页</a> &gt; 编程笔记</span>
	</div>
	<div id="ggxc-position-bottom" class="ggxc-box"></div>
	<h1>Python操作SQLite数据库（非常详细）</h1>
	<div id="ggxc-arctop-pc-1" class="ggxc-box"></div>
	<div id="arc-body">SQLite 是一款轻量型的数据库，是遵守 ACID（atomicity, consistency, isolation, durability，原子性、一致性、隔离性、持久性）的关系数据库管理系统，它的设计目标是嵌入式，目前已经有很多嵌入式产品使用它。<br />
<br />
SQLite 占用的资源非常低，在嵌入式产品中，可能只需要几百 KB 的内存。<br />
<br />
SQLite 能够支持 Windows、Linux、UNIX 等主流的操作系统，同时能够结合多种编程语言，如 Tcl、C#、PHP、Java 等，它还有 ODBC 接口，相比 MySQL、PostgreSQL，在特定场景下，它的处理速度更快。<br />
<br />
目前 SQLite 已经发展到版本 3。
<h2 class="center">
	一、SQLite 简介</h2>
SQLite 是一个进程内的库，它实现了自给自足、无服务器、无须配置和支持事务，它的数据库就是一个文件。<br />
<br />
SQLite 的优点在特定应用场景下表现突出，具体如下：
<ul>
	<li>
		与 MySQL 相比，它开源得更彻底，并且没有任何使用上的限制。</li>
	<li>
		使用方便，在 2.5 以上版本的 Python 中使用 SQLite 无须配置，默认内置。</li>
	<li>
		无须单独购买数据库服务，无服务器进程，配置成本为零。</li>
	<li>
		整个数据库存储在一个文件中，数据导入、导出、备份和恢复都需要复制该文件，维护难度较低，有很好的迁移性。</li>
	<li>
		读速度快，它在数据量不是很大的情况下速度较快，更重要的是省掉了一次数据库远程连接，没有复杂的权限验证，打开就能操作。</li>
	<li>
		支持数据库大小至 2TB。</li>
</ul>
<br />
SQLite 的应用场景有嵌入式设备与物联网、数据分析、数据传输、文件归档、数据容器、内部或临时数据库、在演示或测试期间代替企业数据库、教学与培训、实验性 SQL 语言扩展等。<br />
<br />
实际上，SQLite 是 Python 的内置数据库，换言之，我们不需要安装任何服务器端或客户端软件，也不需要让某个东西作为服务运行，只要用 Python 导入库并开始编码，就会有一个关系数据库管理系统，十分的便捷。
<h2 class="center">
	二、SQLite 的使用</h2>
<h3>
	1. 常用数据类型</h3>
SQLite 采用动态数据类型，会根据存入的值自动判断其数据类型。值的数据类型由值本身决定，而非存储容器。而传统的关系数据库采用静态数据类型，即数据类型在数据表声明时已确定。<br />
<br />
在 SQLite 中，存储分类和数据类型有一定的差别，如 INTEGER 存储分类可以包含 6 种不同长度的 INTEGER 数据类型，然而这些 INTEGER 数据被读入内存时，SQLite 会将其视为占用 8 字节的无符号整型。因此我们即使在数据表声明时明确了字段类型，也可以在该字段中存储其他类型的数据。<br />
<br />
SQLite 中常见的数据类型如表1所示。<br />
<br />
<table>
	<caption>
		表1：SQLite 中常见数据类型</caption>
	<tbody>
		<tr>
			<th>
				类型</th>
			<th>
				描述</th>
		</tr>
		<tr>
			<td>
				NULL</td>
			<td>
				空值</td>
		</tr>
		<tr>
			<td>
				INTEGER</td>
			<td>
				有符号的整数类型</td>
		</tr>
		<tr>
			<td>
				REAL</td>
			<td>
				浮点数类型</td>
		</tr>
		<tr>
			<td>
				TEXT</td>
			<td>
				字符串，使用 UTF-8、UTF-16BE 或 UTF-16LE 存储</td>
		</tr>
		<tr>
			<td>
				BLOB</td>
			<td>
				二进制长对象，我们可以把图片、声音、视频等大文件以二进制形式存入数据库</td>
		</tr>
	</tbody>
</table>
<br />
需要特别说明的是，尽管 SQLite 为我们提供了这种方便，但是考虑到数据库平台的可移植性，我们在实际的开发过程中应尽可能地保证数据类型存储和声明的一致性。
<h4>
	提示</h4>
其他数据类型如下：
<ul>
	<li>
		布尔类型：SQLite 并没有提供专门的布尔存储类型，而是用整型1表示 true，0表示 false。</li>
	<li>
		日期和时间数据类型：和布尔类型一样，SQLite 没有提供专门的日期时间存储类型，而是以 TEXT、REAL 和 INTEGER 类型分别表示该类型，其中：
		<ul>
			<li>
				TEXT 类型表示&ldquo;YYYY-MM-DD HH:MM:SS.SSS&rdquo;格式的日期；</li>
			<li>
				REAL 类型表示以公元 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数；</li>
			<li>
				INTEGER 类型表示以 UNIX 时间形式保存的数据值，即从 1970-01-01 00:00:00 到当前时间所流经的秒数。</li>
		</ul>
	</li>
</ul>
<br />
虽然 SQLite 是轻量级数据库，但是单个 SQLite 文件，能够存储 140TB 的数据。
<h3>
	2. 常用方法</h3>
我们借助 sqlite3 库在 Python 中操作 SQLite 数据库，sqlite3 库的 API 接口如表2所示。<br />
<br />
<table>
	<caption>
		表2：sqlite3 库的 API 接口</caption>
	<tbody>
		<tr>
			<th>
				API</th>
			<th>
				描述</th>
		</tr>
		<tr>
			<td>
				sqlite3.connect(database<br />
				[,timeout,other optional arguments])</td>
			<td>
				该 API 打开一个到数据库的连接。可以使用<code>:memory:</code>来在 RAM 中打开一个到 database 的数据库连接，而不是在磁盘上打开。如果数据库成功打开，则返回一个连接对象。<br />
				<br />
				如果一个数据库被多个连接访问，而其中一个修改了数据库，此时数据库将被锁定，直到事务提交。timeout 参数表示连接等待锁定的持续时间，直到发生异常断开连接。timeout 默认值是 5 秒。<br />
				<br />
				如果给定的数据库名称 filename 不存在，则该 API 将创建一个数据库。我们如果不想在当前目录下创建数据库，可以指定带有路径的文件名，这样就可以在任意目录下创建数据库了。</td>
		</tr>
		<tr>
			<td>
				connection.cursor<br />
				([cursorClass])</td>
			<td>
				创建一个游标（cursor），该方法接受一个单一的可选的参数 cursorClass，该参数必须是一个扩展自 sqlite3.Cursor 的自定义游标类。</td>
		</tr>
		<tr>
			<td>
				cursor.execute(sql[,optional parameters])</td>
			<td>
				执行一个 SQL 语句，该 SQL 语句可以被参数化，即使用占位符代替 SQL 文本，sqlite3 库支持问号和命名占位符这两种类型的占位符。</td>
		</tr>
		<tr>
			<td>
				connection.execute<br />
				(sql[,optional parameters])</td>
			<td>
				是上面执行的由游标对象提供的方法的快捷方式，它通过调用游标方法创建了一个中间的光标对象，然后通过给定的参数调用游标的 execute 方法。</td>
		</tr>
		<tr>
			<td>
				cursor.executemany<br />
				(sql,seq_of_parameters)</td>
			<td>
				对 seq_of_parameters 中的所有参数或映射执行一个 SQL 命令。</td>
		</tr>
		<tr>
			<td>
				connection.executemany<br />
				(sql[,parameters])</td>
			<td>
				一个由调用游标方法创建的中间的光标对象的快捷方式，然后通过给定的参数调用光标的 executemany 方法。</td>
		</tr>
		<tr>
			<td>
				cursor.executescript(sql_script)</td>
			<td>
				一旦接收到脚本，会执行多个 SQL 语句。它首先执行 COMMIT 语句，然后执行作为参数传入的 SQL 脚本。所有的 SQL 语句应该用分号<code>;</code>分隔。</td>
		</tr>
		<tr>
			<td>
				connection.executescript<br />
				(sql_script)</td>
			<td>
				是一个由调用游标方法创建的中间的光标对象的快捷方式，然后通过给定的参数调用光标的 executescript 方法。</td>
		</tr>
		<tr>
			<td>
				connection.total_changes()</td>
			<td>
				返回自数据库连接打开以来被修改、插入或删除的数据总行数。</td>
		</tr>
		<tr>
			<td>
				connection.commit()</td>
			<td>
				该方法用于提交当前的事务。如果未调用该方法，那么自上一次调用 commit() 方法以来所做的任何动作对其他数据库连接是不可见的。</td>
		</tr>
		<tr>
			<td>
				connection.rollback()</td>
			<td>
				该方法回滚自上一次调用 commit() 以来对数据库所做的更改。</td>
		</tr>
		<tr>
			<td>
				connection.close()</td>
			<td>
				该方法用于关闭数据库连接。注意，该方法不会自动调用 commit() 方法。如果之前未调用 commit() 方法，调用该方法时将直接关闭数据库连接，所做的所有更改也将全部丢失。</td>
		</tr>
		<tr>
			<td>
				cursor.fetchone()</td>
			<td>
				该方法用于获取查询结果集中的下一行，返回一个单一的序列，当没有更多可用的数据时，返回 None。</td>
		</tr>
		<tr>
			<td>
				cursor.fetchmany<br />
				([size=cursor.arraysize])</td>
			<td>
				该方法用于获取查询结果集中的下一组，返回一个列表。当没有更多的可用的行时，返回一个空的列表。该方法尝试获取由 size 参数指定的行。</td>
		</tr>
		<tr>
			<td>
				cursor.fetchall()</td>
			<td>
				该方法用于获取查询结果集中所有（剩余）的行，返回一个列表。当没有可用的行时，返回一个空的列表。</td>
		</tr>
	</tbody>
</table>
<h3>
	3. SQLite 使用说明</h3>
Python 2.5.x 以上版本内置了 sqlite3 库，因此我们在 Python 中可以直接使用 SQLite。<br />
<br />
sqlite3 是 Python 标准库中用于使用 SQLite 数据库的库，提供了轻量级文本数据库的全部功能。sqlite3 库的使用包括引入依赖、连接数据库、创建游标对象、执行 SQL 语句和关闭连接5步，下面我们介绍具体的步骤实现。
<h4>
	1) 引入依赖</h4>
具体代码为：
<pre class="python" showmenu="false" shownum="false">
import sqlite3</pre>
<h4>
	2) 连接数据库</h4>
使用 sqlite3 库，必须先创建一个 Connection 对象，表示与程序连接的数据库：
<pre class="python" showmenu="false" shownum="false">
conn = sqlite3.connect(&#39;test.db&#39;)</pre>
<h4>
	3) 创建游标对象</h4>
连接数据库之后，需要从连接中获取 Cursor 游标对象：
<pre class="python" showmenu="false" shownum="false">
cs = conn.cursor()</pre>
<h4>
	4) 执行SQL语句</h4>
调用游标对象的 execute() 方法来执行 SQL 语句。创建表时，我们需要判断 SQLite 中是否存在该表，不存在则创建。<br />
<br />
示例如下：
<pre class="python" showmenu="false" shownum="false">
create_tb_sql=&#39;&#39;&#39;
create table if not exists info
(id  int  primary key, name text, age  int);&#39;&#39;&#39;
cs.execute(create_tb_sql)</pre>
查询时，我们要先通过 execute() 方法执行查询语句，然后获取查询结果，可以调用 Cursor 类的 fetchone() 方法或 fetchall() 方法，获取查询到的第一条或者全部结果：
<pre class="python" showmenu="false" shownum="false">
cs.execute(&#39;select name from info&#39;)
result = cs.fetchall()</pre>
fetchall() 返回结果集中的全部数据，结果是一个元素为元组的列表。每个元组元素是按建表的字段顺序排列。<br />
<br />
注意，游标是有状态的，它可以记录当前已经取到结果的第几个记录，因此我们只可以遍历结果集一次。在上面的查询示例中，如果执行 fetchone() 会返回空值，这一点在测试时需要注意。<br />
<br />
更改（包括增加、更新和删除）数据时，我们要先调用 execute() 方法更改数据库中的数据，然后调用 Connection 对象的 commit() 方法进行提交，否则操作不会被保存：
<pre class="python" showmenu="false" shownum="false">
cs.execute(&#39;insert into info values(?,?,?)&#39;,(1,&#39;Tom&#39;,23))
conn.commit()</pre>
另外，我们可以使用 executemany() 方法来执行多次插入，增加多个记录。
<h4>
	5) 关闭连接</h4>
当所有操作完成，我们可以调用 Connection 对象的 close() 方法，关闭数据库连接：
<pre class="python" showmenu="false" shownum="false">
conn.close()</pre>
<h4>
	提示</h4>
游标对象是一个实现了迭代器和生成器的对象，这个时候游标对象中还没有数据，等到执行完 fetchone() 方法或 fetchall() 方法才返回一个元组，并支持 len() 方法和 index() 方法，这是它实现迭代器的原因。<br />
<br />
游标对象只能遍历结果集一次，即每用完一次之后记录其位置，等到下次再取的时候是从游标处再取而不是从头再来，当取完所有的数据，这个游标对象就没有使用价值了。
<h4>
	SQL 注入攻击</h4>
通常在执行 SQL 语句时，我们需要使用一些 Python 变量的值拼接该语句。<br />
<br />
我们不应该使用 Python 的字符串格式化符，如<code>%s</code>，来拼接查询语句，因为这样可能会导致 SQL 注入攻击。我们应该在SQL语句中，使用<code>?</code>占位符来代替值，然后把对应的值所组成的元组作为 execute() 方法的第二个参数。<br />
<br />
示例如下：
<pre class="python" showmenu="false" shownum="false">
param = (&#39;123&#39;, True)
cs.execute(&#39;&#39;&#39;SELECT comment FROM comment_table WHERE relation_id=? AND merge_mark=?&#39;&#39;&#39;, param)
result_list = cs.fetchall()</pre>
<h2 class="center">
	三、封装示例</h2>
我们利用 Python 的 sqlite3 库实现 SQLite 的增、删、查、改，并将其封装，供后续项目工程引用借鉴，以减少代码量，让代码更加清晰、可读，如代码清单1所示。<br />
<br />
代码清单1：SQLiteUtil.py
<pre class="python">
# -*- coding: utf-8 -*-
# @Time : 2023/7/28 9:50 下午
# @Project : sqlDemo
# @File : SQLiteUtil.py
# @Version: Python3.9.8
　
import sys
import os
import sqlite3
　
class SqliteTool():
    &quot;&quot;&quot;
       简单sqlite数据库工具类
       编写这个类主要是为了封装sqlite，继承此类复用方法
       &quot;&quot;&quot;
    def __init__(self, dbName=&quot;sqlite3Test.db&quot;):
        &quot;&quot;&quot;
        初始化连接&mdash;&mdash;使用完需关闭连接
        :param dbName: 连接库的名字，注意，以&#39;.db&#39;结尾
        &quot;&quot;&quot;
        # 连接数据库
        self._conn = sqlite3.connect(dbName)
        # 创建游标
        self._cur = self._conn.cursor()
　
    def close_con(self):
        &quot;&quot;&quot;
        关闭连接对象&mdash;&mdash;主动调用
        :return:
        &quot;&quot;&quot;
        self._cur.close()
        self._conn.close()
　
    # 创建数据表
    def create_tabel(self, sql: str):
        &quot;&quot;&quot;
        创建表
        :param sql: create sql语句
        :return: True表示创建表成功
        &quot;&quot;&quot;
        try:
            self._cur.execute(sql)
            self._conn.commit()
            print(&quot;[create table success]&quot;)
            return True
        except Exception as e:
            print(&quot;[create table error]&quot;, e)
　
    # 删除数据表
    def drop_table(self, sql: str):
        &quot;&quot;&quot;
        删除表
        :param sql: drop sql语句
        :return: True表示删除成功
        &quot;&quot;&quot;
        try:
            self._cur.execute(sql)
            self._conn.commit()
            return True
        except Exception as e:
            print(&quot;[drop table error]&quot;, e)
            return False
　
    # 插入或更新表数据，一次插入或更新一条数据
    def operate_one(self, sql: str, value: tuple):
        &quot;&quot;&quot;
        插入或更新单条表记录
        :param sql: insert语句或update语句
        :param value: 插入或更新的值，形如（）
        :return: True表示插入或更新成功
        &quot;&quot;&quot;
        try:
            self._cur.execute(sql, value)
            self._conn.commit()
            if &#39;INSERT&#39; in sql.upper():
                print(&quot;[insert one record success]&quot;)
            if &#39;UPDATE&#39; in sql.upper():
                print(&quot;[update one record success]&quot;)
            return True
        except Exception as e:
            print(&quot;[insert/update one record error]&quot;, e)
            self._conn.rollback()
            return False
　
    # 插入或更新表数据，一次插入或更新多条数据
    def operate_many(self, sql: str, value: list):
        &quot;&quot;&quot;
        插入或更新多条表记录
        :param sql: insert语句或update语句
        :param value: 插入或更新的字段的具体值，列表形式为list:[(),()]
        :return: True表示插入或更新成功
        &quot;&quot;&quot;
        try:
            # 调用executemany()方法
            self._cur.executemany(sql, value)
            self._conn.commit()
            if &#39;INSERT&#39; in sql.upper():
                print(&quot;[insert many  records success]&quot;)
            if &#39;UPDATE&#39; in sql.upper():
                print(&quot;[update many  records success]&quot;)
            return True
        except Exception as e:
            print(&quot;[insert/update many  records error]&quot;, e)
            self._conn.rollback()
            return False
　
    # 删除表数据
    def delete_record(self, sql: str):
        &quot;&quot;&quot;
        删除表记录
        :param sql: 删除记录SQL语句
        :return: True表示删除成功
        &quot;&quot;&quot;
        try:
            if &#39;DELETE&#39; in sql.upper():
                self._cur.execute(sql)
                self._conn.commit()
                print(&quot;[detele record success]&quot;)
                return True
            else:
                print(&quot;[sql is not delete]&quot;)
                return False
        except Exception as e:
            print(&quot;[detele record error]&quot;, e)
            return False
　
    # 查询一条数据
    def query_one(self, sql: str, params=None):
        &quot;&quot;&quot;
        查询单条数据
        :param sql: select语句
        :param params: 查询参数，形如()
        :return: 语句查询单条结果
        &quot;&quot;&quot;
        try:
            if params:
                self._cur.execute(sql, params)
            else:
                self._cur.execute(sql)
            # 调用fetchone()方法
            r = self._cur.fetchone()
            print(&quot;[select one record success]&quot;)
            return r
        except Exception as e:
            print(&quot;[select one record error]&quot;, e)
　
    # 查询多条数据
    def query_many(self, sql: str, params=None):
        &quot;&quot;&quot;
        查询多条数据
        :param sql: select语句
        :param params: 查询参数，形如()
        :return: 语句查询多条结果
        &quot;&quot;&quot;
        try:
            if params:
                self._cur.execute(sql, params)
            else:
                self._cur.execute(sql)
            # 调用fetchall()方法
            r = self._cur.fetchall()
            print(&quot;[select many records success]&quot;)
            return r
        except Exception as e:
            print(&quot;[select many records error]&quot;, e)
　
if __name__ == &#39;__main__&#39;:
    # 创建数据表info的SQL语句
    create_tb_sql = &quot;create table if not exists info(id  int  primary key,name text not null,age int not null,address char(50),);&quot;
    # 创建对象
    mySqlite = SqliteTool()
    # 创建数据表
    mySqlite.create_tabel(create_tb_sql)
    # 插入数据
    # 一次插入一条数据
    mySqlite.operate_one(&#39;insert into info values(?,?,?)&#39;, (4, &#39;Tom3&#39;, 22))
    # 一次插入多条数据
    mySqlite.operate_many(&#39;insert into info values(?,?,?)&#39;, [
        (5, &#39;Alice&#39;, 22),
        (6, &#39;John&#39;, 21)])
    &#39;&#39;&#39;
    # 更新数据SQL语句
    update_sql = &quot;update info set age=? where name=?&quot;
    update_value = (22,&#39;Tom&#39;)
    update_values = [(22,&#39;Tom&#39;),(32,&#39;John&#39;)]
    # 一次更新一条数据
    mySqlite.operate_one(update_sql,update_value)
    # 一次更新多条数据
    mySqlite.operate_many(update_sql,update_values)
    &#39;&#39;&#39;
    # 查询数据
    select_sql = &quot;select name from info where age =? and name = ?&quot;
    conn = sqlite3.connect(&quot;sqlite3Test.db&quot;)
    # 创建游标
    cur = conn.cursor()
    result_one = cur.execute(&quot;select * from info where name=:myname &quot;, {&quot;myname&quot;: &#39;Tom&#39;})
    print(result_one.fetchall())
    print(result_one)
    result_many = mySqlite.query_many(select_sql, (23, &#39;Tom&#39;))
    print(result_many)
    # 删除数据
    &#39;&#39;&#39;
    delete_sql = &quot;delete from info where name = &#39;Tom&#39;&quot;
    mySqlite.delete_record(delete_sql)
    &#39;&#39;&#39;
    # 关闭游标和连接
    mySqlite.close_con()</pre>
为了验证上述封装的正确性，我们在 PyCharm 中新建 SQLite 数据库 sqlite3Test，如图1所示。<br />
<br />
<div style="text-align: center;">
	<img alt="在 PyCharm 中新建 SQLite 数据库" src="../uploads/allimg/230728/1-230HR04Rc63_2.png" /><br />
	图1：在 PyCharm 中新建 SQLite 数据库</div>
<br />
然后，新建表 info，如图2所示，表 info 包含 id、name 和 age 字段。<br />
<br />
<div style="text-align: center;">
	<img alt="新建数据表info" src="../uploads/allimg/230728/1-230HR04U0T2_2.png" /><br />
	图2：新建数据表 info</div>
<br />
最后，在 if __name__== &#39;__main__&#39; 代码块中执行增、删、改和查，从图3可以看到，插入数据成功。<br />
<br />
<div style="text-align: center;">
	<img alt="插入数据成功" src="../uploads/allimg/230728/1-230HR05330937_2.png" /><br />
	图3：插入数据成功</div>
<h2 class="center">
	四、总结</h2>
使用 sqlite3 的过程中的一些知识和技巧总结如下。
<h4>
	1) 使用批量操作</h4>
如果需要一次性向数据库插入很多行，不应该使用 execute() 方法，sqlite3 提供了一种批量操作的办法 executemany()。
<h4>
	2) 游标是可以遍历的</h4>
直接使用游标进行遍历，可以在得到自己想要的结果后立即释放资源。当然，如果我们预先知道自己需要多少记录，则可以使用 limit 语句限制返回的行数。
<h4>
	3) 推迟索引创建</h4>
如果数据表需要一些索引，同时创建数据表时需要向表中插入大量数据。那么需要先插入数据再创建索引，这样做可以带来一定的性能提升。
<h4>
	4) 使用占位符来做 Python 插值</h4>
使用 Python 字符串操作来向 SQL 中插入值，这样做很不安全，sqlite3 提供了一个更安全的办法&mdash;&mdash;占位符。同时，Python 的<code>%s</code>替换值的语法，在 execute() 方法中根本无法使用，采用正确方式如下：
<pre class="python" showmenu="false" shownum="false">
my_timestamp = (1,)
c.execute(&#39;SELECT * FROM events WHERE ts = ?&#39;, my_timestamp)</pre>
</div>
	<div id="ggxc-weixin-arcbottom">
	<p>关注公众号「<span class="col-green">站长严长生</span>」，在手机上阅读所有教程，随时随地都能学习。内含一款搜索神器，免费下载全网书籍和视频。</p>
	<p style="margin-top:12px; text-align:center;">
		<img src="../templets/new/images/material/qrcode_mp_4.png" alt="公众号二维码" width="160" /><br />
		<span class="col-green">微信扫码关注公众号</span>
	</p>
</div>
	<div id="nice-arcs" class="box-bottom">
    <h4>推荐阅读</h4>
    <ul class="clearfix">
<li><a href="niz69i_8.html" title="一套完整的嵌入式开发学习路线（高薪就业版）" target="_blank">一套完整的嵌入式开发学习路线（高薪就业版）</a></li>
<li><a href="tnnfqo_4.html" title="一套课程卖1万，TMD太贵了！" target="_blank">一套课程卖1万，TMD太贵了！</a></li>
<li><a href="unnurw_4.html" title="跑了3000公里，见了一位大佬" target="_blank">跑了3000公里，见了一位大佬</a></li>
<li><a href="1021_2.html" title="Linux /etc/inittab：设置（修改）系统默认运行级别" target="_blank">Linux /etc/inittab：设置（修改）系统默认运行级别</a></li>
<li><a href="3372_2.html" title="行逻辑链接的顺序表（压缩存储稀疏矩阵）详解" target="_blank">行逻辑链接的顺序表（压缩存储稀疏矩阵）详解</a></li>
<li><a href="vip_7101_2.html" title="Python异常处理机制到底有什么用？" target="_blank">Python异常处理机制到底有什么用？</a></li>
<li><a href="7234_2.html" title="MySQL存储过程是什么？" target="_blank">MySQL存储过程是什么？</a></li>
<li><a href="../maven2/archetype_2.html" title="Maven Archetype(原型/模板)" target="_blank">Maven Archetype(原型/模板)</a></li>
<li><a href="../c/atoi_2.html" title="C语言atoi()：将字符串转换为整数" target="_blank">C语言atoi()：将字符串转换为整数</a></li>
<li><a href="../c/rand_2.html" title="C语言rand()函数：生成随机数" target="_blank">C语言rand()函数：生成随机数</a></li>
</ul>
</div>
	
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 10150;
window.arcId = "3138xh74GYcuKGojIg3lRyUMrTDATpdyqrvSLhdqbWu6ASf7iR0VyH+tJ+Fn";
window.typeidChain = "119";
</script>
<div id="footer" class="clearfix">
	<div class="info left">
	<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
	<p>
		<a href="8066_2.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
		<a href="8092_3.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
		<a href="8097_2.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
		<a href="9648_2.html" target="_blank" rel="nofollow">公众号</a> <span>|</span>
		<a href="8093_2.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
		<a href="../sitemap/sitemap_2.html" target="_blank" rel="nofollow">网站地图</a>
	</p>
	<p>Copyright ©2012-2022 biancheng.net, <a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow" style="color:#666;">冀ICP备2022013920号</a>, <img height="13" src="../templets/new/images/gongan_2.png" alt="公安备案图标" /><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13110202001352" target="_blank" rel="nofollow" style="color:#666;">冀公网安备13110202001352号</a>
	</p>
	</div>
	<img id="logo_bottom" class="right" src="https://m.biancheng.net/templets/new/images/logo_bottom_2.gif" alt="底部Logo" />
	<span id="return-top"><b>↑</b></span>
</div>

<div id="addweixin-widget">
	<p>
		<script type="text/javascript">
			/*var suffix = 'c';
			var thisMin = (new Date()).getMinutes();
			if(thisMin>=40){
				suffix = 'd';
			}else if(thisMin>=20){
				suffix = 'e';
			}else{
				suffix = 'c';
			}
			document.write('<img src="https://m.biancheng.net/templets/new/images/material/qrcode_wx_'%20+%20suffix%20+'.png?v=1.7.07" alt="微信交流群" width="120" /><br />');*/
		</script>
		<img src="https://m.biancheng.net/templets/new/images/material/qrcode_mp_4.png" alt="微信交流群" width="120" />
		<span>关注微信公众号，加入官方交流群。内含一款搜索神器，免费下载全网书籍和视频。</span>
	</p>
	<span id="close-addweixin-widget" class="iconfont iconfont-close"></span>
</div>

<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.7.07";

</script>

<script src="https://m.biancheng.net/templets/new/script/jquery1.12.4.min_2.js"></script>
<script src="https://m.biancheng.net/templets/new/script/common_2.js"></script>
<!-- 51la V6 -->
<span style="display: none;">
<script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"KDf6QzBhogyQjall",ck:"KDf6QzBhogyQjall",autoTrack:true})</script>
</span>
<!-- 51la V5 -->
<!-- <span style="display: none;"><script type="text/javascript" src="https://js.users.51.la/21368967.js"></script></span> -->
</body>
</html>