<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<!-- 启用Chromium高速渲染模式 -->
<meta name="renderer" content="webkit" />
<meta name="force-rendering" content="webkit"/>
<!-- 禁止百度转码 -->
<meta name="applicable-device" content="pc,mobile" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<!-- 禁止识别电话号码 -->
<meta name="format-detection" content="telephone=no" />

<link rel="shortcut icon" href="../favicon_3.ico" />
<link href="../templets/new/style/common_2.css" rel="stylesheet" />
<title>C++结构体完全攻略（超详细）</title>
<meta name="description" content="结构体 是一个由程序员定义的数据类型，可以容纳许多不同的数据值。在过去，面向对象编程的应用尚未普及之前，程序员通常使用这些从逻辑上连接在一起的数据组合到一个单元中。" />
</head>
<body>
<div id="topbar" class="clearfix">
	<ul id="product-type" class="left">
		<li>
			<a href="../m_biancheng_default_2.html"><span class="iconfont iconfont-home"></span>首页</a>
		</li>
		<li class="active">
			<a href="../sitemap/sitemap_2.html" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
		</li>
		<li>
			<a href="../fudao_biancheng_default.html" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
		</li>
		<li>
			<a href="niz69i_5.html" target="_blank"><span class="iconfont iconfont-chip"></span>嵌入式学习路线</a>
		</li>
		<!-- <li>
			<a href="https://www.54benniao.com/c_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-c-course"></span>C语言高级课程</a>
		</li>
		<li>
			<a href="https://www.54benniao.com/java_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-java-course"></span>Java高级课程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/q2a/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-q2a"></span>一对一答疑</a>
		</li> -->
	</ul>
</div>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="../m_biancheng_default_2.html">
		<img height="26" src="../templets/new/images/logo_2.png" alt="C语言中文网" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li class="wap-yes"><a href="../m_biancheng_default_2.html">首页</a></li>
		<li><a href="../c/c_4.html">C语言教程</a></li>
		<li><a href="../cplus/cplus_2.html">C++教程</a></li>
		<li><a href="../python/python_2.html">Python教程</a></li>
		<li><a href="../java/java_2.html">Java教程</a></li>
		<li><a href="../linux_tutorial/linux_tutorial_2.html">Linux入门</a></li>
		<li><a href="../sitemap/sitemap_2.html" title="网站地图">更多&gt;&gt;</a></li>
	</ul>
	<a href="http://vip.biancheng.net/?from=topbar" class="user-info iconfont iconfont-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main-no-course" class="clearfix">
	<div class="arc-info">
		<span class="position"><span class="iconfont iconfont-home2"></span> <a href="../m_biancheng_default_2.html">首页</a> &gt; 编程笔记</span>
	</div>
	<div id="ggxc-position-bottom" class="ggxc-box"></div>
	<h1>C++结构体完全攻略（超详细）</h1>
	<div id="ggxc-arctop-pc-1" class="ggxc-box"></div>
	<div id="arc-body"><span style="color:#008000;">结构体</span>是一个由程序员定义的数据类型，可以容纳许多不同的数据值。在过去，面向对象编程的应用尚未普及之前，程序员通常使用这些从逻辑上连接在一起的数据组合到一个单元中。一旦结构体类型被声明并且其数据成员被标识，即可创建该类型的多个变量，就像可以为同一个类创建多个对象一样。<br />
<br />
虽然今天结构体较少使用，但知道它们是什么，以及如何使用它们仍然很重要，这并不仅仅是因为可以在较老的程序中遇到它们，还因为在某些情况下，类的实例无法使用，这时必须使用结构体。<br />
<br />
声明结构体的方式和声明类的方式大致相同，其区别如下：
<ul>
	<li>
		使用关键字 struct 而不是关键字 class。</li>
	<li>
		尽管结构体可以包含成员函数，但它们很少这样做。所以，通常情况下结构体声明只会声明成员变量。</li>
	<li>
		结构体声明通常不包括 public 或 private 的访问修饰符。</li>
	<li>
		类成员默认情况是私有的，而结构体的成员则默认为 public。程序员通常希望它们保持公开，只需使用默认值即可。</li>
</ul>
<blockquote>
	<p>
		<a href='../cplus/cplus_2.html' target='_blank'>C++</a> 中保留了C语言的 struct 关键字，struct 和 class 基本是通用的，只有几个细节不同，感兴趣的小伙伴请<span class="btn-more-info" keyword="class和struct" type="more">猛击这里</span>了解详情。</p>
</blockquote>
以下是一个结构体声明的示例，该结构体将 5 个变量绑定在一起，保存了员工的工资单数据。这个特殊结构体的名称是 PayRoll。请注意，它以大写字母开头，这和类名使用大写字母开头的约定一样。另外还要注意，与类声明一样，在结构体声明的大括号后面必须有一个分号。<br />
<pre class="cpp">
struct PayRoll
{
    int empNumber;
    string name;
    double hours,payRate,grossPay;
};</pre>
正如在类的对象被创建之前，类声明不会被实例化一样，结构体声明不会创建任何结构体的实例。本示例中的结构体声明只是告诉编译器PayRoll结构体看起来的样子。它本质上是创建一个名为 PayRoll 的新数据类型。<br />
<br />
定义 PayRoll 结构体的变量和定义其他任何变量的方式并无二致，首先列出数据类型，然后是变量名称。以下定义语句创建了 PayRoll 结构体的 3 个变量：<br />
<p class="info-box">
	PayRoll deptHead, foreman, associate;</p>
它们每一个都是 PayRoll 结构体的实例，可以被分配和拥有自己的内存，以保存其成员数据。请注意，尽管 3 个结构体变量具有不同的名称，但每个变量都包含具有相同名称的成员，如图 1 所示。
<div style="text-align: center;">
	<br />
	<img alt="每个结构体变量都包含具有相同名称的成员" src="../uploads/allimg/181119/2-1Q1191K930627_2.gif" /><br />
	图 1 每个结构体变量都包含具有相同名称的成员</div>
<h2>
	初始化结构体</h2>
<span style="color:#b22222;">当定义结构体变量时，可以通过两种方式初始化它：使用初始化列表或构造函数。</span><br />
<h4>
	初始化列表</h4>
初始化结构体变量成员的最简单的方法是使用初始化列表。初始化列表是用于初始化一组内存位置的值列表。列表中的项目用逗号分隔并用大括号括起来。<br />
<br />
例如，假设已经声明了以下 Date 结构体：<br />
<pre class="cpp">
struct Date
{
    int day, month, year;
};</pre>
定义和初始化 Date 变量的方式是：先指定变量名，后接赋值运算符和初始化列表，如下所示：<br />
<p class="info-box">
	Date birthday = {23, 8, 1983};</p>
该声明定义 birthday 是一个 Date 结构体的变量，大括号内的值按顺序分配给其成员。所以 birthday 的数据成员已初始化，如图 2 所示。<br />
<div style="text-align: center;">
	<br />
	<img alt="已经初始化的 birthday 的数据成员" src="../uploads/allimg/181119/2-1Q1191K952334_2.gif" /><br />
	图 2 已经初始化的 birthday 的数据成员</div>
<br />
也可以仅初始化结构体变量的部分成员。例如，如果仅知道要存储的生日是8月23日， 但不知道年份，则可以按以下方式定义和初始化变量：<br />
<p class="info-box">
	Date birthday = {23,8};</p>
这里只有 day 和 month 成员被初始化，year 成员未初始化。但是，如果某个结构成员未被初始化，则所有跟在它后面的成员都需要保留为未初始化。使用初始化列表时，C++ 不提供跳过成员的方法。以下语句试图跳过 month 成员的初始化。这是不合法的。<br />
<p class="info-box">
	Date birthday = {23,1983}; //非法</p>
还有一点很重要，不能在结构体声明中初始化结构体成员，因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量。例如，以下声明是非法的：<br />
<pre class="cpp">
//非法结构体声明
struct Date
{
    int day = 23,
    month = 8,
    year = 1983;
}；</pre>
因为结构体声明只声明一个结构体&ldquo;看起来是什么样子的&rdquo;，所以不会在内存中创建成员变量。只有通过定义该结构体类型的变量来实例化结构体，才有地方存储初始值。<br />
<h2>
	构造函数初始化结构体</h2>
虽然初始化列表易于使用，但它有两个缺点：
<ol>
	<li>
		如果有某个成员未被初始化，那么在这种情况下，跟随在该成员后面的成员都不能初始化。</li>
	<li>
		如果结构体包括任何诸如字符串之类的对象，那么在许多编译器上它都将无法运行。</li>
</ol>
<br />
在这些情况下，可以使用构造函数来初始化结构体成员变量，这和初始化类成员变量是相同的。与类构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。因为默认情况下，所有结构体成员都是公开的，所以不需要使用关键字 public。<br />
<br />
以下是一个名为 Employee 的结构体的声明语句，它包含一个具有两参数的构造函数，以便在创建一个 Employee 变量而不向其传递任何参数时，提供默认值：<br />
<pre class="cpp">
struct Employee
{
    string name;    // 员工姓名
    int vacationDays,    // 允许的年假
    daysUsed;    //已使用的年假天数
    Employee (string n =&quot;&quot;,int d = 0)    // 构造函数
    {
        name = n;
        vacationDays = 10;
        daysUsed = d;
    }
};</pre>
<h2>
	访问结构体成员</h2>
结构体成员的访问方式与类的公共成员一样，都是使用点运算符。但是，类的数据成员通常是私有的，必须通过函数访问。因为结构数据成员是公共的，所以它们可以被直接访问，并且可以像常规变量一样使用。以下语句即可为前面创建的每个 PayRoll 变量的 empNumber 成员赋值：<br />
<pre class="cpp">
deptHead.empNumber = 475;
foreman.empNumber = 897;
associate.empNumber = 729;</pre>
以下语句将显示 deptHead 变量所有成员的内容：<br />
<pre class="cpp">
cout &lt;&lt; deptHead.empNumber &lt;&lt; endl;
cout &lt;&lt; deptHead.name &lt;&lt; endl;
cout &lt;&lt; deptHead.hours &lt;&lt; endl;
cout &lt;&lt; deptHead.payRate &lt;&lt; endl;
cout &lt;&lt; deptHead.grossPay &lt;&lt; endl;</pre>
下面的程序是使用 PayRoll 结构体的完整程序。请注意，在 cin 语句、cout 语句和数学运 算中，单个结构体成员的用法和常规变量基本上是一样的。<br />
<pre class="cpp">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
u<a href='https://m.biancheng.net/ref/sin.html' target='_blank'>sin</a>g namespace std;

struct PayRoll
{
    int    empNumber; // Employee number
    string name;    // Employee name
    double hours,    // Hours worked
    payRate; // Hourly pay rate
};

int main()
{
    PayRoll employee; // Employee is a PayRoll structure
    double grossPay; // Gross amount the employee earned this week
    cout &lt;&lt; &quot;Enter the employee1s number:&quot;;
    cin &gt;&gt; employee.empNumber;
    cout &lt;&lt; &quot;Enter the employee&#39;s name: &quot;;
    cin.ignore();// Skip the &#39;\n&#39; character left in the input buffer
    getline(cin, employee.name);
    cout &lt;&lt; &quot;Hours worked this week: &quot;;
    cin &gt;&gt; employee.hours;
    cout &lt;&lt; &quot;Employee&#39;s hourly pay rate: &quot;;
    cin &gt;&gt; employee.payRate;
   
    // Calculate the employee&#39;s gross pay
    grossPay = employee.hours * employee.payRate;
    // Display the results
    cout &lt;&lt; &quot;\nHere is the employee1s payroll data:\n&quot;;
    cout &lt;&lt; &quot;Name:    &quot; &lt;&lt; employee.name &lt;&lt; endl;
    cout &lt;&lt; &quot;Employee number: &quot; &lt;&lt; employee.empNumber &lt;&lt; endl;
    cout &lt;&lt; &quot;Hours worked:    &quot; &lt;&lt; employee.hours &lt;&lt; endl;
    cout &lt;&lt; &quot;Hourly pay rate: &quot; &lt;&lt; employee.payRate &lt;&lt; endl;
    cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(2);
    cout &lt;&lt; &quot;Gross pay: $&quot; &lt;&lt; grossPay &lt;&lt; endl;
    return 0;
}</pre>
程序输出结果：
<p class="info-box">
	Enter the employee1s number:2214<br />
	Enter the employee&#39;s name: Jack Smith<br />
	Hours worked this week: 40<br />
	Employee&#39;s hourly pay rate: 12.50<br />
	<br />
	Here is the employee1s payroll data:<br />
	Name:&nbsp;&nbsp; Jack Smith<br />
	Employee number: 2214<br />
	Hours worked:&nbsp;&nbsp; 40<br />
	Hourly pay rate: 12.5<br />
	Gross pay: $500.00</p>
程序中，变量 employee 被定义在第 17 行，它是 Payroll 结构体的一个实例。此后就可以通过变量名称和点运算符来访问其中的 5 个数据成员。例如，在第 22 行中，以下语句将读取变量的 empNumber 成员中的值：<br />
<p class="info-box">
	cin &gt;&gt; employee.empNumber; //正确</p>
如果试图通过结构体类型的名称来访问该成员，那么结果将是错误的：<br />
<p class="info-box">
	cin &gt;&gt; Payroll.empNumber; //错误</p>
<h2>
	结构体嵌套</h2>
正如一个类的对象可以嵌套在另一个类中一样，一个结构体的实例也可以嵌套在另一个结构体中。例如，来看以下声明：
<pre class="cpp">
struct Costs
{
    double wholesale;
    double retail;
};

struct Item
{
    string partNum;
    string description;
    Costs pricing;
};</pre>
Costs 结构体有两个 double 类型成员，wholesale 和 retail。Item 结构体有 3 个成员，前 2 个是 partNum 和 description，它们都是 string 对象。第 3 个是 pricing，它是一个嵌套的 Costs 结构体。如果定义了一个名为 widge t的 Item 结构体，则图 3 说明了其成员。
<div style="text-align: center;">
	<br />
	<img alt="在 widget 的成员中包含一个嵌套结构体" src="../uploads/allimg/181119/2-1Q1191P021K4_2.gif" /><br />
	图 3 在 widget 的成员中包含一个嵌套结构体</div>
<br />
它们可以按以下方式访问：<br />
<pre class="cpp">
widget.partnum = &quot;123A&quot;;
widget.description = &quot;iron widget&quot;;
widget.pricing.wholesale = 100.0;
widget.pricing.retail = 150.0;</pre>
请注意，wholesale 和 retail 不是 widget 的成员，pricing 才是。要访问 wholesale 和 retail，必须首先访问 widget 的定价 pricing，然后由于它是一个 Costs 结构体，所以同样可以使用点运算符访问其 wholesale 和 retail 成员。<br />
<br />
还要注意，对于所有结构体来说，访问成员时必须使用成员名称，而不是结构体名称。例如，以下语句不合法：<br />
<pre class="cpp">
cout &lt;&lt; widget.retail;    // 错误
cout &lt;&lt; widget.Costs.wholesale;    // 错误</pre>
在决定是否使用嵌套结构体时，请考虑各种成员的相关性。一个结构体将逻辑上属于一体的项目绑定在一起。通常，结构体的成员是描述某个对象的属性。在上述示例中，对象是一个 widget（小零部件），而 partNum（部件编号）、description（描述）、wholesale（批发）和 retail（零售）价格都是其属性。<br />
<br />
当某些属性相关并形成对象属性的逻辑子组时，将它们绑定在一起并使用嵌套结构体是有意义的。请注意下面程序内部结构体中属性的相关性，它使用了嵌套结构体。
<pre class="cpp">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
using namespace std;

struct CostInfo
{
    double food, // Food <a href='https://m.biancheng.net/ref/cos.html' target='_blank'>cos</a>ts
    medical, // Medical costs
    license, // License fee
    misc; // Miscellaneous costs
};
struct PetInfo
{
    string name; // Pet name
    string type; // Pet type
    int age; // Pet age
    CostInfo cost;
    PetInfo() // Default constructor
    {
        name = &quot;unknown&quot;;
        type = &quot;unknown&quot;;
        age = 0;
        cost.food = cost.medical = cost.license = cost.misc = 0.00;
    }
};

int main()
{
    PetInfo pet;
    pet.name = &quot;Sassy&quot;;
    pet.type = &quot;cat&quot;;
    pet.age = 5;
    pet.cost.food = 300.00;
    pet.cost.medical = 200.00;
    pet.cost.license = 7.00;
    cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(2);
    cout &lt;&lt; &quot;Annual costs for my &quot; &lt;&lt; pet.age &lt;&lt; &quot;&mdash;year&mdash;old &quot;&lt;&lt; pet.type &lt;&lt; &quot; &quot; &lt;&lt; pet.name &lt;&lt; &quot; are $&quot;&lt;&lt; (pet.cost.food + pet.cost.medical +pet.cost.license + pet.cost.misc) &lt;&lt; endl;
    return 0;
}</pre>
<p class="info-box">
	程序输出结果：<br />
	Annual costs for my 5-year-old cat Sassy are $507.00</p>
<h2>
	将结构体传递给函数</h2>
与类对象一样，结构体变量也可以通过值、引用和常量引用传递给函数。默认情况下，它们通过值传递，这意味着需要生成整个原始结构的副本并传递给函数。因为不希望浪费时间来复制整个结构体，所以，除非结构很小，否则一般会通过引用将结构体传递给函数。但是，这样意味着函数可以访问原始结构的成员变量，从而可能更改它们。如果不想让函数更改任何成员变量值，那么可以考虑将结构体变量作为一个常量引用传递给函数。<br />
<br />
下面程序定义了一个结构体变量并将其传递给了两个函数。
<pre class="cpp">
//程序1
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
using namespace std;

struct Invltem// Holds data for an inventory item
{
    int partNum; // Part number
    string description; // Item description
    int onHand; // Units on hand
    double price; // Unit price
};
// Function prototypes
void getltemData(InvItem &amp;) ;

void showItem(const InvItem &amp;);

int main()
{
    InvItem part; // Define an Invltem structure variable.
    getItemData(part);
    showItem(part);
    return 0;
}

void getItemData(InvItem &amp;item)
{
    cout &lt;&lt; &quot;Enter the part number: &quot;;
    cin &gt;&gt; item.partNum;
    cout &lt;&lt; &quot;Enter the part description: &quot;;
    cin.get();
    getline (cin, item.description);
    cout &lt;&lt; &quot;Enter the quantity on hand: &quot;;
    cin &gt;&gt; item.onHand;
    cout &lt;&lt; &quot;Enter the unit price: &quot;;
    cin &gt;&gt; item.price;
}
void showItem(const InvItem &amp;item)
{
    cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(2) &lt;&lt; endl;
    cout &lt;&lt; &quot;Part Number : &quot; &lt;&lt; item.partNum &lt;&lt; endl;
    cout &lt;&lt; &quot;Description : &quot; &lt;&lt; item.description &lt;&lt; endl;
    cout &lt;&lt; &quot;Units On Hand : &quot; &lt;&lt; item.onHand &lt;&lt; endl;
    cout &lt;&lt; &quot;Price    : $&quot; &lt;&lt; item.price &lt;&lt; endl;
}</pre>
程序输出结果：
<p class="info-box">
	Enter the part number: 800<br />
	Enter the part description: Screwdriver<br />
	Enter the quantity on hand: 135<br />
	Enter the unit price: 1.25<br />
	<br />
	Part Number : 800<br />
	Description : Screwdriver<br />
	Units On Hand: 135<br />
	Price : $1.25</p>
<h2>
	从函数返回一个结构体</h2>
也可以从函数返回结构体变量。在这种情况下，函数的返回类型是结构体的名称。可以改写程序 1 以允许 getItemData 函数创建 Invltem 结构体的局部实例，将数据值放入其成员变量中，然后将其传递回 main，而不是将其作为引用变量从 main 接收。<br />
<br />
以下是修改后的 getltemData 函数的样子：
<pre class="cpp">
InvItem getItemData()
{
    InvItem item;
    cout &lt;&lt; &quot;Enter the part number:&quot;;
    cin &gt;&gt; item.partNum;
    cout &lt;&lt; &quot;Enter the part description: &quot;;
    cin.get();
    getline(cin, item.description);
    cout &lt;&lt; &quot;Enter the quantity on hand: &quot;;
    cin &gt;&gt; item.onHand;
    cout &lt;&lt; &quot;Enter the unit price: &quot;;
    cin &gt;&gt; item.price;
    return item;
}</pre>
以下是从 main 中调用它的方法：<br />
<p class="info-box">
	part = getItemData();</p>
注意，C++ 只允许从函数返回单个值。然而，结构体提供了解决这一限制的方法。即使一个结构体可能有几个成员，它在技术上还是一个单一的对象。通过在结构体中打包多个值，可以从函数返回任意数量的值。<br />
</div>
	<div id="ggxc-weixin-arcbottom">
	<p>关注公众号「<span class="col-green">站长严长生</span>」，在手机上阅读所有教程，随时随地都能学习。内含一款搜索神器，免费下载全网书籍和视频。</p>
	<p style="margin-top:12px; text-align:center;">
		<img src="../templets/new/images/material/qrcode_mp_4.png" alt="公众号二维码" width="160" /><br />
		<span class="col-green">微信扫码关注公众号</span>
	</p>
</div>
	<div id="nice-arcs" class="box-bottom">
    <h4>推荐阅读</h4>
    <ul class="clearfix">
<li><a href="niz69i_8.html" title="一套完整的嵌入式开发学习路线（高薪就业版）" target="_blank">一套完整的嵌入式开发学习路线（高薪就业版）</a></li>
<li><a href="tnnfqo_4.html" title="一套课程卖1万，TMD太贵了！" target="_blank">一套课程卖1万，TMD太贵了！</a></li>
<li><a href="unnurw_4.html" title="跑了3000公里，见了一位大佬" target="_blank">跑了3000公里，见了一位大佬</a></li>
<li><a href="7704_2.html" title="Django QuerySet查询API攻略" target="_blank">Django QuerySet查询API攻略</a></li>
<li><a href="7973_2.html" title="Django Form表单自定义验证规则" target="_blank">Django Form表单自定义验证规则</a></li>
<li><a href="../spring_mvc/9679_2.html" title="Spring MVC JSON数据交互" target="_blank">Spring MVC JSON数据交互</a></li>
<li><a href="en6pv1_2.html" title="Django框架介绍（非常详细）" target="_blank">Django框架介绍（非常详细）</a></li>
<li><a href="eb3j1zc_2.html" title="C# switch case语句详解" target="_blank">C# switch case语句详解</a></li>
<li><a href="0brwao1_2.html" title="git commit命令：保存仓库的历史记录" target="_blank">git commit命令：保存仓库的历史记录</a></li>
<li><a href="sljkfjb_2.html" title="C++ #define用法详解" target="_blank">C++ #define用法详解</a></li>
</ul>
</div>
	
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 1407;
window.arcId = "13c2oWKGYODEZpKyiyGzjbUnturr+sSYnT2xftL74KErK/fDVGqCBfVAv/o";
window.typeidChain = "120|119";
</script>
<div id="footer" class="clearfix">
	<div class="info left">
	<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
	<p>
		<a href="8066_2.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
		<a href="8092_3.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
		<a href="8097_2.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
		<a href="9648_2.html" target="_blank" rel="nofollow">公众号</a> <span>|</span>
		<a href="8093_2.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
		<a href="../sitemap/sitemap_2.html" target="_blank" rel="nofollow">网站地图</a>
	</p>
	<p>Copyright ©2012-2022 biancheng.net, <a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow" style="color:#666;">冀ICP备2022013920号</a>, <img height="13" src="../templets/new/images/gongan_2.png" alt="公安备案图标" /><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13110202001352" target="_blank" rel="nofollow" style="color:#666;">冀公网安备13110202001352号</a>
	</p>
	</div>
	<img id="logo_bottom" class="right" src="https://m.biancheng.net/templets/new/images/logo_bottom_2.gif" alt="底部Logo" />
	<span id="return-top"><b>↑</b></span>
</div>

<div id="addweixin-widget">
	<p>
		<script type="text/javascript">
			/*var suffix = 'c';
			var thisMin = (new Date()).getMinutes();
			if(thisMin>=40){
				suffix = 'd';
			}else if(thisMin>=20){
				suffix = 'e';
			}else{
				suffix = 'c';
			}
			document.write('<img src="https://m.biancheng.net/templets/new/images/material/qrcode_wx_'%20+%20suffix%20+'.png?v=1.7.07" alt="微信交流群" width="120" /><br />');*/
		</script>
		<img src="https://m.biancheng.net/templets/new/images/material/qrcode_mp_4.png" alt="微信交流群" width="120" />
		<span>关注微信公众号，加入官方交流群。内含一款搜索神器，免费下载全网书籍和视频。</span>
	</p>
	<span id="close-addweixin-widget" class="iconfont iconfont-close"></span>
</div>

<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.7.07";

</script>

<script src="https://m.biancheng.net/templets/new/script/jquery1.12.4.min_2.js"></script>
<script src="https://m.biancheng.net/templets/new/script/common_2.js"></script>
<!-- 51la V6 -->
<span style="display: none;">
<script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"KDf6QzBhogyQjall",ck:"KDf6QzBhogyQjall",autoTrack:true})</script>
</span>
<!-- 51la V5 -->
<!-- <span style="display: none;"><script type="text/javascript" src="https://js.users.51.la/21368967.js"></script></span> -->
</body>
</html>