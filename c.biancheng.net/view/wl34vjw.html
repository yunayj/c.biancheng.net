<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="renderer" content="webkit" />
<meta name="force-rendering" content="webkit"/>
<meta name="applicable-device" content="pc,mobile" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="format-detection" content="telephone=no" />
<link rel="shortcut icon" href="../favicon.ico" />
<link href="../templets/new/style/common.css" rel="stylesheet" />
<title>FastAPI框架入门教程（简明版）</title>
<meta name="description" content="Web 应用框架可以帮助我们高效地编写 Web 应用。 当我们在浏览器访问一个网址，发起 HTTP 请求，这时 Web 应用框架就负责处理这个请求，分配不同的访问地址到相应的代码，然后生成" />
</head>
<body>
<div id="topbar" class="clearfix">
<ul id="product-type" class="left">
<li>
<a href="../c_biancheng_default.html"><span class="iconfont iconfont-home"></span>首页</a>
</li>
<li class="active">
<a href="../sitemap/sitemap_3.html" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
</li>
<li>
<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
</li>
<li>
<a href="../fudao_biancheng_default.html" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
</li>
<li>
<a href="niz69i.html" target="_blank"><span class="iconfont iconfont-chip"></span>嵌入式学习路线</a>
</li>
</ul>
</div>
<div id="header" class="clearfix">
<a id="logo" class="left" href="../c_biancheng_default.html">
<img height="26" src="../templets/new/images/logo.png" alt="C语言中文网" />
</a>
<ul id="nav-main" class="hover-none left clearfix">
<li class="wap-yes"><a href="../c_biancheng_default.html">首页</a></li>
<li><a href="../c/c_3.html">C语言教程</a></li>
<li><a href="../cplus/cplus.html">C++教程</a></li>
<li><a href="../python/python.html">Python教程</a></li>
<li><a href="../java/java_3.html">Java教程</a></li>
<li><a href="../linux_tutorial/linux_tutorial.html">Linux入门</a></li>
<li><a href="../sitemap/sitemap_3.html" title="网站地图">更多&gt;&gt;</a></li>
</ul>
<a href="http://vip.biancheng.net/?from=topbar" class="user-info iconfont iconfont-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main-no-course" class="clearfix">
<div class="arc-info">
<span class="position"><span class="iconfont iconfont-home2"></span> <a href="../c_biancheng_default.html">首页</a> &gt; 编程笔记</span>
</div>
<div id="ggxc-position-bottom" class="ggxc-box"></div>
<h1>FastAPI框架入门教程（简明版）</h1>
<div id="ggxc-arctop-pc-1" class="ggxc-box"></div>
<div id="arc-body">Web 应用框架可以帮助我们高效地编写 Web 应用。<br />
<br />
当我们在浏览器访问一个网址，发起 HTTP 请求，这时 Web 应用框架就负责处理这个请求，分配不同的访问地址到相应的代码，然后生成 HTML，创建带有内容的 HTTP 响应。<br />
<br />
借助Web应用框架，我们可以不用编写处理HTTP请求与响应等底层代码。
<h2 class="center">
一、FastAPI 简介</h2>
谈到 Python 的 Web 应用框架，首先就是大而全的 Django，正是&ldquo;大而全&rdquo;这3个字，让很多入门开发人员望而却步，不过 Django 仍然是 Web 应用开发的首选。<br />
<br />
然后就是以微小和可扩展著称的 Flask，Flask 的发展势头很迅猛，Docker 官方的很多示例都使用了 Flask。<br />
<br />
当前，有一定规模的团队都会顺应前后端分离的潮流。本教程主要讲解近两年&ldquo;横空出世&rdquo;的 Python 后端服务接口快速开发框架 FastAPI。<br />
<br />
FastAPI 是一个基于 Python 的 Web 应用后端开发框架，它的开发效率高，具有较少的代码量；它在开发完成后会自动生成 API 使用文档；它基于 Pydantic，可以方便地实现数据校验；它具有更高的性能，支持 ASGI（asynchronous server gateway interface，异步服务器网关接口）规范，也就是支持异步和 WebSocket。<br />
<br />
总而言之，Web 应用框架主要用来搭建一些简单的平台，如接口测试平台、mock 平台等，这要求应用框架开发效率高、学习成本低。<br />
<br />
FastAPI 具有如下特性：
<ul>
<li>
快速：可与 Node.js 和 Go 比肩的极高性能，是较快的 Python Web 应用框架之一。</li>
<li>
编码高效：可将功能开发速度提高 2~3 倍。</li>
<li>
错误更少：减少约 40％ 的因人为（开发人员）导致的错误。</li>
<li>
智能：极佳的编辑器支持。处处皆可自动补全，可减少调试时间。</li>
<li>
简单：易于学习和使用。开发人员阅读文档的时间更短。</li>
<li>
精简：可使代码重复最小化。通过不同的参数声明实现丰富功能。</li>
<li>
健壮：生产可用级别的代码。可自动生成交互式文档。</li>
</ul>
<h2 class="center">
二、使用FastAPI</h2>
我们先通过 pip install 命令或直接在 PyCharm 中安装 fastapi 和 uvicorn 这两个库，本教程示例中使用的 fastapi 的版本为 0.75.1，uvicorn 的版本为 0.17.6。<br />
<br />
简单的 Web 应用开发只需要4步即可完成。
<ul>
<li>
创建一个 APP 实例</li>
<li>
编写一个路径操作装饰器（如 @app.get(&quot;/&quot;)）</li>
<li>
编写一个路径操作函数</li>
<li>
运行开发服务器（如 uvicorn main:app--reload）</li>
</ul>
<br />
下面我们创建一个 helloWorld.py 文件，展示如何在 PyCharm 中使用 FastAPI 开发一个简单的应用。注意，文件名字要和启动服务的 APP 名字相同，具体实现如代码清单1所示。<br />
<br />
代码清单1：helloWorld
<pre class="python">
# -*- coding: utf-8 -*-
# @Project : fastapiDemo
# @File    : helloWorld.py
# @Date    : 2023-08-26

from fastapi import FastAPI
# 创建一个APP实例
app = FastAPI()
　
# 添加路径操作装饰器和路径操作函数
@app.get(&quot;/&quot;)
async def demo():
    return {&quot;Hello&quot;: &quot;World&quot;}
　
if __name__ == &quot;__main__&quot;:
    import uvicorn
    # 启动服务，注意APP前面的文件名称
    uvicorn.run(app=&#39;helloWorld:app&#39;, host=&quot;127.0.0.1&quot;, port=8010, reload=True, debug=True)</pre>
在 PyCharm 启动 FastAPI 服务成功如图1所示。在浏览器中输入地址，即可显示<code>{&quot;Hello&quot;: &quot;World&quot;}</code>，如图2所示。<br />
<br />
<div style="text-align: center;">
<img alt="启动FastAPI服务成功" src="../uploads/allimg/230826/1-230R61R35b49.png" /><br />
图1：启动FastAPI服务成功<br />
<br />
<img alt="在浏览器中验证服务" src="../uploads/allimg/230826/1-230R61R412T6.png" /><br />
图2：在浏览器中验证服务</div>
<h4>
关于&nbsp;Uvicorn</h4>
ASGI 是介于网络服务和 Python 应用之间的标准接口，是为 Python 语言定义的 Web 服务器和 Web 应用或框架之间的通用协议，能够处理多种通用的协议类型，包括 HTTP、HTTP/2 和 WebSocket。<br />
<br />
ASGI 帮助 Python 在 Web 应用框架上和 Node.js 及 Go 相竞争，目标是获得高性能的 IO 密集型任务。<br />
<br />
Uvicorn 是基于 uvloop 和 httptools 构建的一种高效的 ASGI 服务器，负责从客户端接收请求，将请求转发给应用，将应用的响应返回给客户端。我们向 Uvicorn 发送请求，Uvicorn 解析请求并转发给 Python 程序的 app 处理请求，并将处理结果返回。<br />
<br />
可以认为，Uvicorn 和 Apache、Nginx 类似的东西。<br />
<br />
Gunicorn 是成熟的、功能齐全的服务器，Uvicorn 内部包含 Guicorn 的 workers 类，允许运行 ASGI 应用，这些 workers 继承了 Uvicorn 高性能的特点，并且可以使用 Guicorn 来进行进程管理。这样我们动态增加或减少进程数量，平滑地重启工作进程，或者升级服务器而无须停机。<br />
<br />
FastAPI 推荐使用 Uvicorn 来部署应用，但在生产环境中，Guicorn 大概是最简单的管理 Uvicorn 的方式。在部署生产环境时，我们推荐使用 Guicorn 和 Uvicorn 的 worker 类。
<h3>
1. 项目结构</h3>
我们观察官网的示例会发现启动一个项目都是通过简简单单的一个 py 文件来完成请求和响应内容，但是实际工程的模块往往是庞大和复杂的。<br />
<br />
当我们基于 Django 框架开发 Web 应用时，能够通过命令创建出一个项目，并且整个项目结构清晰、规整，而类似 Flask、FastAPI 这些轻量级的框架项目组织需要我们自己来做，清晰、规范和合理的项目组织结构，对开发的效率和质量都有很大的提高。<br />
<br />
FastAPI 提供了类似 Flask 中 Blueprints 功能的工具，它可以在保持灵活性的同时构建应用。子包中的每一个模块需要解耦开，此时可以使用 APIRouter 进行管理，可以理解为小型的 FastAPI 应用，然后将各个部分组合到 FastAPI 主体上即可。<br />
<br />
依据此原理，下面我们构建工厂模式创建 FastAPI 项目示例 myFastAPI，供大家借鉴。<br />
<br />
我们把项目划分为5个目录，分别为 api、extensions、settings、utils 和 tests。当然，大家可以对这些目录做适当的裁剪或修订。
<ul>
<li>
api：项目框架核心，包含整体项目逻辑和路由视图，示例 myFastAPI 中有 shopdemo 和 websocketdemo 两个子项目，而在 shopdemo 子项目下有 goods 和 home 两个模块，其下有各自的路由视图，分开管理，并通过 api 包中的 __init__.py 创建的工厂模式生成应用对象统一注册使用。</li>
<li>
extensions：包含项目依赖的一些扩展包，如日志管理。</li>
<li>
settings：包含项目的配置文件，如测试环境配置、生产环境等。</li>
<li>
utils：工具目录，一般用于存放我们抽象出来的公共类或根据业务场景抽象出来可复用的一些工具类。</li>
<li>
tests：测试案例，项目代码质量检测的脚本，这部分主要包含我们开发过程中的一些测试案例，用于对我们的代码进行单元测试。</li>
</ul>
<br />
该项目实例是基于 pipenv 构建的，所以通过 Pipfile 和 Pipfile.lock 文件进行依赖的管理。在项目工程目录下，使用命令行执行命令 tree-FC，即可显示如下的项目树结构：
<pre class="info-box">
├── Pipfile
├── Pipfile.lock
├── README.md
├── api/
│   ├── __init__.py*                # 创建工厂模式生成应用对象
│   ├── shopdemo/                   # 子项目shopdemo
│   │   ├── __init__.py*           # 路由汇总，包括该子项目下所有模块的路由
│   │   ├── database.py*
│   │   ├── goods/                 # goods模块
│   │   │   ├── __init__.py*
│   │   │   └── goods.py*         # goods模块的路由视图
│   │   ├── home/                  # home模块
│   │   │   ├── __init__.py*
│   │   │   └── home.py*          # home模块的路由视图
│   │   └── schemas.py*
│   └── websocketdemo/
│       ├── __init__.py*
│       └── chat.py*
├── extensions/
│   ├── __init__.py*
│   └── logger.py*
├── main.py*                         #程序入口
├── settings/
│   ├── __init__.py*
│   └── development_config.py*
├── tests/
│   ├── __init__.py*
│   └── test_home.py*
└── utils/
├── __init__.py*
├── custom_exc.py*
└── response_code.py*</pre>
<h3>
2. 数据和参数</h3>
在 FastAPI 中我们可以自定义数据模型。<br />
<br />
下面示例展示了如何用 Python 来定义一个数据模型类，用 Pydantic 来校验数据：
<pre class="python">
class User(BaseModel):
    id: int
    name = &#39;jack guo&#39;
    signup_timestamp: datetime = None
    friends: List[int] = []</pre>
其中，要求 id 必须为 int 类型，name 必须为 str 类型且有默认值，signup_timestamp 必须为 datetime 类型且默认值为 None，friends 必须为 List 类型且元素类型要求 int，默认值为 []。
<p class="tip-box">
FastAPI 基于 Pydantic，Pydantic 主要用于类型强制检查，若参数的赋值不符合类型要求就会抛出异常。对于 API 服务，支持类型检查会让服务更加健壮，加快开发速度，因为开发人员不需要对代码一行一行地做类型检查。</p>
FastAPI 中的参数如表1所示，这些是我们在构建请求参数时必须掌握的。<br />
<div>
&nbsp;</div>
<table>
<caption>
表1：FastAPI 中的参数</caption>
<tbody>
<tr>
<th>
参数</th>
<th>
含义</th>
</tr>
<tr>
<td>
url</td>
<td>
定义在 URL 中的参数</td>
</tr>
<tr>
<td>
param</td>
<td>
通常是 URL 后面 ?xx=xx 定义的参数</td>
</tr>
<tr>
<td>
body</td>
<td>
在请求主体中携带的 JSON 参数</td>
</tr>
<tr>
<td>
form</td>
<td>
在请求主体中携带的 Web 表单参数</td>
</tr>
<tr>
<td>
cookie</td>
<td>
在请求的 cookie 中携带的参数</td>
</tr>
<tr>
<td>
file</td>
<td>
客户端上传的文件</td>
</tr>
</tbody>
</table>
<h4>
1) url 参数</h4>
url 参数是一种应用广泛的参数，很多地方都会使用，将信息放在 URL 中，例如 https://www. example.com/u/91bc345f7c84 中<code>91bc345f7c84</code>就是 url 参数，它被传递到函数中。<br />
<br />
假设 URL 为 http://127.0.0.1:8080/items/abcd，那么路径 path 就是 /items/abcd。<br />
<br />
请看下面的代码：
<pre class="python">
from fastapi import FastAPI
app = FastAPI()
app.get(&quot;/echo/{text}&quot;)           # 注意，这里text将是函数定义的参数名
async def getEchoApi(text:str):   # 通过定义参数类型可以让fastapi进行默认的参数检查
    return {&quot;echo&quot;:text}</pre>
这段示例代码很简单，将 URL 中的内容原样返回，当我们访问URL&ldquo;localhost:8000/echo/ HelloWorld&rdquo;，返回的内容将是 {&quot;echo&quot;:text}。
<h4>
2)&nbsp;param参数</h4>
param 参数可能是最常见的参数，当我们百度时，可以在地址栏上看到这样的地址 https://www. example.com/s?ie=UTF-8&amp;wd=fastapi，其中<code>?</code>后面设置了参数 ie 为 &quot;UTF-8&quot;，参数 wd 为 &quot;fastapi&quot;。<br />
<br />
这种参数直接在函数中定义即可：
<pre class="python">
from fastapi import FastAPI
app=FastAPI()
app.get(&quot;/echo2/&quot;)                 # 注意，这里URL中没有定义参数
async def getEchoApi(text:str):    # 会自动发现它不是url参数,然后识别为param参数
    return {&quot;echo&quot;:text}</pre>
运行后，localhost:8000/echo2?text=HelloWorld 返回 {&quot;echo&quot;:text}。
<h4>
3) body 参数</h4>
body 参数常用于数据的提交等操作中。注意，GET 操作是不支持携带请求主体的，我们可以使用诸如 POST、PUT 等请求方式。<br />
<br />
示例如下：
<pre class="python">
from fastapi import FastAPI
from pydantic import BaseModel         # FastAPI的一个依赖，需要从pydantic中引入
app=FastAPI()
class EchoArgs(BaseModel):             # 继承BaseModel
    text:str                           # 定义一个字符串型参数
app.post(&quot;/echo/&quot;)                     # GET不支持请求体，更换请求方法
async def postEchoApi(args:EchoArgs):  # 设置刚才定义的参数
    return {&quot;echo&quot;:item.text}          # 原样返回</pre>
<h4>
4) form 参数</h4>
form 参数常用于 HTML 表单，表单浏览器有另一套规则，所以在这里要定义其参数类型为表单参数。<br />
<br />
示例如下：
<pre class="python">
from fastapi import FastAPI,Form       # 引入Form用于定义表单参数
app=FastAPI()
app.post(&quot;/echo/&quot;)
async def postEchoApi(text:str=Form(None)):    # 通过Form设置参数
    return {&quot;echo&quot;:text}                       # 原样返回</pre>
<h4>
5) cookie 参数</h4>
cookie 参数一般用于标识用户、记录用户习惯等。后来的 session 和 token 也要用到 cookie 技术。cookie 本质是一种在客户端保存的数据，每次请求都会携带，我们可以在响应中对其进行设置。<br />
<br />
示例如下：
<pre class="python">
from fastapi import FastAPI,Cookie
app=FastAPI()
app.post(&quot;/echo/&quot;)
async def postEchoApi(text:str=Cookie(None)):
    return {&quot;echo&quot;:text}    # 原样返回</pre>
可以发现，cookie 参数的定义和 form 参数的定义十分相似。
<h4>
6) file 参数</h4>
file 参数用于接收客户端上传的文件，有两种方式：
<pre class="python">
from fastapi import FastAPI,File,UploadFile    # 引入文件相关操作
app=FastAPI()
app.post(&quot;/upload/1&quot;)
async def postUploadFile1Api(file:bytes=File(None)):
    #...    # 文件相关操作方式1
app.post(&quot;/upload/=2&quot;)
async def postUploadFile2Api(file:UploadFile=File(None)):
    #...    # 文件相关操作方式2</pre>
其中，上传的文件可以使用 bytes 或 UploadFile 两种格式，但推荐使用 UploadFile 方式。因为存储在内存中的文件大小超过上限后，将被存储在磁盘中。这意味着它可以很好地用于大型文件如图像、视频、大型二进制文件等的使用，让大型文件不会占用所有内存。
<h3>
3. 请求和响应</h3>
Web 开发的核心是接收客户端的请求，并进行逻辑处理，然后返回响应给客户端，接下来我们将介绍如何利用 FastAPI 获取请求的相关信息。
<h4>
1) 请求</h4>
常见的请求有 GET 请求和 POST 请求。<br />
<br />
GET 请求的参数有两种，一种是查询参数（param参数），一种是路径参数（url参数）。当声明路径参数以外的其他函数参数时，FastAPI 会将其自动解析为查询参数。<br />
<br />
和路径参数不同，查询参数可以是可选非必填的，也可以具有默认值，即在方法中声明的参数就是查询参数。示例如下：
<pre class="python">
from fastapi import FastAPI
app = FastAPI()
# 路径参数+查询参数
@app.get(&quot;/items/{item_id}&quot;)
async def read_item(item_id: str, name: str, extra: Optional[str] = None):
return {&quot;item_id&quot;: item_id, &quot;name&quot;: name}</pre>
路径参数就是将路径上的某一部分变成参数，可通过请求传递，然后利用 FastAPI 解析：
<pre class="python">
app = FastAPI()
@app.get(&quot;/items/{item_id}&quot;)
async def read_item(item_id:str):
    return {&quot;item_id&quot;: item_id}</pre>
路径中的 item_id 将会被解析，传递给方法中的 item_id。当请求路径 http://127.0.0.1:8000/ items/foo，会返回结果 {&quot;item_id&quot;:&quot;foo&quot;}。<br />
<br />
另外，在路径操作函数中声明 Request 类型的参数，FastAPI 将会传递 Request 对象给这个参数。<br />
<br />
例如，我们想在路径操作函数中获取客户端的地址信息：
<pre class="python">
from fastapi import FastAPI, Request
app = FastAPI()
@app.get(&quot;/items/{item_id}&quot;)
def read_root(item_id: str, request: Request):
    client_host = request.client.host  # 获取请求的客户端的host信息
return {&quot;client_host&quot;: client_host, &quot;item_id&quot;: item_id}</pre>
根据官方文档，Request 对象中的常用字段和获取方法如表2所示。<br />
<br />
<table>
<caption>
表2：Request 对象中的常用字段和获取方法</caption>
<tbody>
<tr>
<th>
常用字段</th>
<th>
获取方法</th>
</tr>
<tr>
<td>
Method</td>
<td>
通过 request.method 方法获取。</td>
</tr>
<tr>
<td>
URL</td>
<td>
通过 request.url 方法获取。request.url 方法包含其他组件，如 request.url.path、request.url.port。</td>
</tr>
<tr>
<td>
Headers</td>
<td>
通过 request.headers 方法获取。例如通过 request.headers[&#39;Content-Type&#39;] 获取 Content-Type。</td>
</tr>
<tr>
<td>
Query Parameters</td>
<td>
通过 request.query_params 方法获取。例如通过 request.query_params[&#39;search&#39;] 访问查询参数。</td>
</tr>
<tr>
<td>
Path Parameters</td>
<td>
通过 request.path_params 方法获取，参数显示为多字典。例如 request.path_params[&#39;name&#39;]。</td>
</tr>
<tr>
<td>
Client Address</td>
<td>
通过 request.client 为主机和端口保存一个命名的二元组。我们可以通过 request.client.host和request.client.port 获取详细信息。</td>
</tr>
<tr>
<td>
Cookies</td>
<td>
通过 request.cookies 方法获取，例如使用 request.cookies.get(&#39;mycookie&#39;) 访问其中的字段。</td>
</tr>
<tr>
<td>
Body</td>
<td>
返回的主体根据我们的用例由多个接口组成。例如，使用 request.body() 获取字节数据；将表单数据或大部分数据作为 request.form() 发送；使用 request.json() 将输入解析为 JSON 格式。</td>
</tr>
</tbody>
</table>
<br />
接下来是 POST 请求，通过发送请求体（request body）来传递请求数据，FastAPI 提倡使用 Pydantic 模型来定义请求体。<br />
<br />
使用 Pydantic 模型的示例如下：
<pre class="python">
from fastapi import FastAPI
from typing import Optional
from pydantic import BaseModel
app = FastAPI()
# 自定义一个Pydantic模型
class Item(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None
@app.post(&quot;/items/&quot;)
# item参数的类型指定为Item
async def create_item(item: Item):
    return item</pre>
参数指定为 Pydantic 模型，FastAPI 会将请求体识别为 JSON 格式的字符串，若有需要，会将字符串转换成相应的类型和验证数据。<br />
<br />
在上面的示例中，item 接收到完整的请求体数据，拥有了所有属性及其类型。下面示例同时声明请求体、路径参数和查询参数，FastAPI 可以识别出它们，并从正确的位置获取数据。<br />
<br />
请看代码：
<pre class="python">
from typing import Optional
from fastapi import FastAPI
from pydantic import BaseModel
class Item(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None
app = FastAPI()
@app.put(&quot;/items/{item_id}&quot;)
async def create_item(
       # 路径参数
       item_id: int,
       # 请求体：模型类型
       item: Item,
       # 查询参数
       name: Optional[str] = None):
    result = {&quot;item_id&quot;: item_id, **item.dict()}
    print(result)
    if name:
       # 如果查询参数name不为空，则替换掉item参数里面的name属性值
       result.update({&quot;name&quot;: name})
    return result</pre>
FastAPI 识别参数的逻辑为：
<ul>
<li>
如果参数也在路径中声明，它将解释为路径参数，如 item_id；</li>
<li>
如果参数是单数类型（如 int、float、str、bool 等），它将被解释为查询参数，如 name；</li>
<li>
如果参数被声明为 Pydantic 模型的类型，它将被解析为请求体，如 item。</li>
</ul>
<h4>
2) 响应</h4>
在 FastAPI 路径操作中，通常直接返回 dict、list、Pydantic 模型等数据类型。<br />
<br />
FastAPI 通过 jsonable_encoder 函数自动把返回数据转换为 JSON 格式，然后把 JSON 格式兼容的数据传送给 JSONResponse 对象并返回给终端用户。<br />
<br />
在一些情况下，直接返回 Response 对象能让路径操作更灵活。例如自定义头信息、自定义 cookie 信息等情况，我们可以直接返回 Response 对象或者它的子类。JSONResponse 实际上也是 Response 的子类。<br />
<br />
利用 jsonable_encoder 把数据转换成 JSON 格式的示例如下：
<pre class="python">
from datetime import datetime
from typing import Optional
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from pydantic import BaseModel
　
class Item(BaseModel):
    title: str
    timestamp: datetime
    description: Optional[str] = None
app = FastAPI()
@app.put(&quot;/items/{id}&quot;)
def update_item(id: str, item: Item):
    json_compatible_item_data = jsonable_encoder(item)
    return JSONResponse(content=json_compatible_item_data)</pre>
一般的响应 JSON 格式是由3个字段组成，如下所示：
<pre class="info-box">
{
   &quot;code&quot;: 200,  // 统一成功状态码，需要前后端约定
   &quot;data&quot;: xxx,  // 可以是任意类型数据，有接口文档对接
   &quot;message&quot;: &quot;success&quot;  // 消息提示，是状态码的简要补充说明
}</pre>
前端一般有响应拦截处理，如果状态码不是约定成功的状态码就拦截，然后提示 message 里面的消息，如果是就返回 data 里面的数据。<br />
<br />
我们创建一个 response_code.py 文件来封装响应状态：
<pre class="python">
from fastapi import status
from fastapi.responses import JSONResponse, Response
from typing import Union
# 注意，*号是指调用的时候要指定参数，例如resp_200（data=xxxx)
def resp_200(*, data: Union[list, dict, str]) -&gt; Response:
    return JSONResponse(
        status_code=status.HTTP_200_OK,
        content={
            &#39;code&#39;: 200,
            &#39;message&#39;: &quot;Success&quot;,
            &#39;data&#39;: data,
        }
    )</pre>
所有响应状态都封装在这里，其他的响应状态，大家可以自行扩展。调用该封装比较简单,导入并调用，以此来返回 JSON 格式：
<pre class="python">
from api.utils import response_code
@router.get(&quot;/table/list&quot;)
async def get_table_list():
    return response_code.resp_200(data={
    &quot;items&quot;:  [&quot;xx&quot;, &quot;xx&quot;]
    })</pre>
<br />
另外，在实际工程中，经常需要设置 Response Header，有如下两种实现场景。<br />
<br />
① 路径操作函数声明 Response 参数来设置 Header：
<pre class="python">
from fastapi import FastAPI, Response
app = FastAPI()
@app.get(&quot;/item&quot;)
# 路径操作函数声明一个Response类型的参数
async def get_item(response: Response):
    response.headers[&quot;x-token&quot;] = &quot;XXX&quot;
    return {&quot;name&quot;: &quot;设置 headers&quot;}</pre>
<br />
② 在路径操作函数内，通过 return response 来设置 Header：
<pre class="python">
from fastapi import FastAPI, Response
from fastapi.responses import JSONResponse
app = FastAPI()
@app.get(&quot;/items&quot;)
async def get_item():
    response = JSONResponse(content={&quot;name&quot;: &quot;JSONResponse&quot;})
    response.headers[&quot;x-auth-token&quot;] = &quot;XXX_TOKEN&quot;
    return response</pre>
<h3>
4. 视图路由</h3>
通常我们在开发应用时会用到路由，例如 Flask 的 blueprint、Django 的 urls 等，其目的都是进行路由汇总管理。FastAPI 也不例外，其拥有 APIRouter。<br />
<br />
在大型的应用或者 Web API 中，将所有的请求方法写在同一个处理文件下，会导致代码没有逻辑性，这样既不利于程序的扩展，也不利于程序日后的维护。在 FastAPI 中，我们可以通过 APIRouter 来处理多程序分类。
<h4>
1) 创建 APIRouter</h4>
假设专门用于处理用户的文件是子模块 /app/routers/users.py，我们希望用户相关的路径操作可以与其他代码分开，使代码简洁明了，在 routers 子包中，针对前端不同的功能，后端有不同的接口模块与之对应，例如 items.py 与 users.py。<br />
<br />
items.py 代码示例如下：
<pre class="python">
from fastapi import APIRouter, Depends
from dependencies import get_query_token
router = APIRouter(
    prefix=&quot;/items&quot;,  # 前缀只在这个模块中使用
    tags=[&quot;items&quot;],
    dependencies=[Depends(get_query_token)]
)
@router.get(&quot;/&quot;)
async def read_items():
    result = [
        {&quot;name&quot;: &quot;apple&quot;},
        {&quot;name&quot;: &quot;pear&quot;}
    ]
    return result</pre>
<br />
users.py 代码示例如下：
<pre class="python">
from fastapi import APIRouter
router = APIRouter()
@router.get(&quot;/users/&quot;, tags=[&quot;users&quot;])
async def read_user():
    return [{&quot;username&quot;: &quot;zhangsan&quot;}, {&quot;username&quot;: &quot;lisi&quot;}]
@router.get(&quot;/users/me&quot;, tags=[&quot;users&quot;])
async def read_user_me():
    return {&quot;username&quot;: &quot;zhangsan&quot;}</pre>
<h4>
2) 注册APIRouter</h4>
我们要将刚刚的 APIRouter 注册到核心对象，导入 FastAPI 和声明的 APIRouter 实例，并将上述模块整合到 FastAPI 主体：
<pre class="python">
from fastapi import FastAPI, Depends
from internal import admin
from routers import items, users
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__))) # 防止相对路径导入出错
app = FastAPI()
# 将其他单独模块进行整合
app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix=&quot;/admin&quot;,
    tags=[&quot;admin&quot;]
)
@app.get(&quot;/&quot;)
async def root():
    return {&quot;message&quot;: &quot;Application...&quot;}</pre>
其中，include_router() 函数用于注册。完成后使用 FastAPI() 生成的 app 来启动服务即可。
<h3>
5. 日志文件</h3>
Python 虽然内置了 logging 库，但是配置比较麻烦，于是有人开发了一个日志扩展库 loguru，该库集成到 FastAPI 比较简单。<br />
<br />
该库的开发人员建议直接使用全局对象，所以在示例中，我们直接新建一个文件夹 extensions/ 来存放扩展文件，然后在文件目录下创建 logger.py 文件，进行简单配置。示例如下：
<pre class="python">
import os
import time
from loguru import logger
　
basedir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# 定位到日志文件
log_path = os.path.join(basedir, &#39;logs&#39;)
if not os.path.exists(log_path):
    os.mkdir(log_path)
log_path_error = os.path.join(log_path, f&#39;{time.strftime(&quot;%Y-%m-%d&quot;)}_error.log&#39;)
# 简单配置日志
logger.add(log_path_error, rotation=&quot;12:00&quot;, retention=&quot;5 days&quot;, enqueue=True)</pre>
<h2 class="center">
三、封装示例</h2>
WebSocket 可以理解为 Web +套接字（socket），它是基于套接字的工作于应用层的一种在单个 TCP 连接上进行全双工通信的协议。<br />
<br />
WebSocket 的最大特点是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，可以理解为 WebSocket 是服务器推送技术的一种。<br />
<br />
FastAPI 的 WebSocket 官方示例中有一个实现多个用户即时沟通的示例，但这个示例只能实现多个用户在一起沟通，而不能实现多个用户随便分组沟通，因此我们对这个示例进行修改，以实现多房间多用户的沟通场景。<br />
<br />
在本教程中，我们将演示如何在 FastAPI 应用中创建一个 WebSocket，然后在 WebSocket 路由中通过 await 等待连接和收发消息。
<p class="tip-box">
这里可以收发文本、二进制和 JSON 格式的数据内容。</p>
代码清单2：chat
<pre class="python">
# -*- coding: utf-8 -*-
# @Project : fastapiDemo
# @File    : chat.py
# @Date    : 2023-08-26
　
# 分组发送JSON格式的数据
from typing import Set, Dict, List
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
　
app = FastAPI()
　
class ConnectionManager:
    def __init__(self):
        # 存放激活的连接
        # self.active_connections: Set[Dict[str, WebSocket]] = set()
        self.active_connections: List[Dict[str, WebSocket]] = []
　
    async def connect(self, user: str, ws: WebSocket):
        # 连接
        await ws.accept()
        self.active_connections.append({&quot;user&quot;: user, &quot;ws&quot;: ws})
　
    def disconnect(self, user: str, ws: WebSocket):
        # 关闭时移除ws对象
        self.active_connections.remove({&quot;user&quot;: user, &quot;ws&quot;: ws})
　
    @staticmethod
    async def send_personal_message(message: dict, ws: WebSocket):
        # 发送个人消息
        await ws.send_json(message)
　
    async def send_other_message(self, message: dict, user: str):
        # 发送个人消息
        for connection in self.active_connections:
            if connection[&quot;user&quot;] == user:
                await connection[&#39;ws&#39;].send_json(message)
　
    async def broadcast(self, data: dict):
        # 广播消息
        for connection in self.active_connections:
            await connection[&#39;ws&#39;].send_json(data)
　
manager = ConnectionManager()
　
@app.websocket(&quot;/ws/{user}&quot;)
async def websocket_endpoint(ws: WebSocket, user: str):
    await manager.connect(user, ws)
    await manager.broadcast({&quot;user&quot;: user, &quot;message&quot;: &quot;进入聊天&quot;})
    try:
        while True:
            data = await ws.receive_json()
            print(data, type(data))
            send_user = data.get(&quot;send_user&quot;)
            if send_user:
                await manager.send_personal_message(data, ws)
                await manager.send_other_message(data, send_user)
            else:
                await manager.broadcast({&quot;user&quot;: user, &quot;message&quot;: data[&#39;message&#39;]})
    except WebSocketDisconnect:
        manager.disconnect(user, ws)
        await manager.broadcast({&quot;user&quot;: user, &quot;message&quot;: &quot;离开&quot;})
　
if __name__ == &quot;__main__&quot;:
    import uvicorn
    # 官方推荐是用命令后启动uvicorn main:app --host=127.0.0.1 --port=8010 --reload
    uvicorn.run(app=&#39;chat2:app&#39;, host=&quot;127.0.0.1&quot;, port=8010, reload=True, debug=True)</pre>
为了验证上述代码的正确性，在<code>if __name__ == &quot;__main__&quot;:</code>代码块中，利用 Uvicorn 启动 APP 服务，启动成功后，如图3所示。<br />
<br />
<div style="text-align: center;">
<img alt="APP 服务启动成功" src="../uploads/allimg/230826/1-230R61R450339.png" /><br />
图3：APP 服务启动成功</div>
<br />
图4是多用户多窗口建立聊天。图5是 User1 发送广播群聊消息，User2 和 User3 能够收到消息。图6是 User1 发送个人聊天消息，只发给 User2，User3 是收不到的。<br />
<br />
<div style="text-align: center;">
<img alt="多用户多窗口建立聊天" src="../uploads/allimg/230826/1-230R61R509206.png" /><br />
图4：多用户多窗口建立聊天<br />
<br />
<img alt="发送广播群聊消息" src="../uploads/allimg/230826/1-230R61R524Z3.png" /><br />
图5：发送广播群聊消息<br />
<br />
<img alt="发送个人聊天消息" src="../uploads/allimg/230826/1-230R61R53b31.png" /><br />
图6：发送个人聊天消息</div>
<h4>
可能遇到的错误</h4>
FastAPI 自带支持 WebSocket，这可以很好地实现简单需求，在这里我们介绍使用 FastAPI 自带 WebSocket 时可能遇到的错误及解决方法。<br />
<br />
错误警告信息如下：
<pre class="info-box">
WARNING:  Unsupported upgrade request.
WARNING:  No supported WebSocket library detected. Please use &#39;pip install uvicorn[standard]&#39;, or install &#39;websockets&#39; or &#39;wsproto&#39; manually.
WARNING:  Unsupported upgrade request.</pre>
究其原因是：Uvicorn 在新版本（大于或等于版本 0.12）后，不会自动提供 WebSocket 实现。<br />
<br />
有如下两种解决方法。<br />
① 先卸载已有版本：
<p class="info-box">
pip uninstall unicorn</p>
然后重新安装指定版本：
<p class="info-box">
pip install uvicorn[standard]</p>
<br />
① 先安装 websockets，FastAPI 自带的 WebSocket 也是基于 websockets 运行的：
<p class="info-box">
from fastapi import FastAPI, WebSocket, WebSocketDisconnect</p>
</div>
<div id="ggxc-weixin-arcbottom">
<p>关注公众号「<span class="col-green">站长严长生</span>」，在手机上阅读所有教程，随时随地都能学习。内含一款搜索神器，免费下载全网书籍和视频。</p>
<p style="margin-top:12px; text-align:center;">
<img src="../templets/new/images/material/qrcode_mp.png" alt="公众号二维码" width="160" /><br />
<span class="col-green">微信扫码关注公众号</span>
</p>
</div>
<div id="nice-arcs" class="box-bottom">
<h4>推荐阅读</h4>
<ul class="clearfix">
<li><a href="niz69i_4.html" title="一套完整的嵌入式开发学习路线（高薪就业版）" target="_blank">一套完整的嵌入式开发学习路线（高薪就业版）</a></li>
<li><a href="tnnfqo_2.html" title="一套课程卖1万，TMD太贵了！" target="_blank">一套课程卖1万，TMD太贵了！</a></li>
<li><a href="unnurw_2.html" title="跑了3000公里，见了一位大佬" target="_blank">跑了3000公里，见了一位大佬</a></li>
<li><a href="3851.html" title="Qt下载（多种下载通道+所有版本）" target="_blank">Qt下载（多种下载通道+所有版本）</a></li>
<li><a href="9429.html" title="Qt自定义信号和槽函数" target="_blank">Qt自定义信号和槽函数</a></li>
<li><a href="wq66h5.html" title="Java for循环用法详解" target="_blank">Java for循环用法详解</a></li>
<li><a href="1nq3rk.html" title="C语言中有哪些运算符" target="_blank">C语言中有哪些运算符</a></li>
<li><a href="zinzn4.html" title="Python turtle入门教程（简明版）" target="_blank">Python turtle入门教程（简明版）</a></li>
<li><a href="../c/sscanf.html" title="C语言sscanf()：从数组中格式化读取数据" target="_blank">C语言sscanf()：从数组中格式化读取数据</a></li>
<li><a href="70wavq1.html" title="C++内联函数详解" target="_blank">C++内联函数详解</a></li>
</ul>
</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 10320;
window.arcId = "03a2zZDjoOTeyeD25J1QaBdXkhFtXRp/4e6HZJs+zvRP/N2Wn+nD6U/Ma6si";
window.typeidChain = "145|119";
</script>
<div id="footer" class="clearfix">
<div class="info left">
<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
<p>
<a href="8066.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
<a href="8092_2.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
<a href="8097.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
<a href="9648.html" target="_blank" rel="nofollow">公众号</a> <span>|</span>
<a href="8093.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
<a href="../sitemap/sitemap_3.html" target="_blank" rel="nofollow">网站地图</a>
</p>
<p>Copyright ©2012-2022 biancheng.net, <a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow" style="color:#666;">冀ICP备2022013920号</a>, <img height="13" src="../templets/new/images/gongan.png" alt="公安备案图标" /><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13110202001352" target="_blank" rel="nofollow" style="color:#666;">冀公网安备13110202001352号</a>
</p>
</div>
<img id="logo_bottom" class="right" src="https://c.biancheng.net/templets/new/images/logo_bottom.gif" alt="底部Logo" />
<span id="return-top"><b>↑</b></span>
</div>
<div id="addweixin-widget">
<p>
<script type="text/javascript">
			/*var suffix = 'c';
			var thisMin = (new Date()).getMinutes();
			if(thisMin>=40){
				suffix = 'd';
			}else if(thisMin>=20){
				suffix = 'e';
			}else{
				suffix = 'c';
			}
			document.write('<img src="https://c.biancheng.net/templets/new/images/material/qrcode_wx_'%20+%20suffix%20+'.png?v=1.7.07" alt="微信交流群" width="120" /><br />');*/
		</script>
<img src="../templets/new/images/material/qrcode_mp_2.png" alt="微信交流群" width="120" />
<span>关注微信公众号，加入官方交流群。内含一款搜索神器，免费下载全网书籍和视频。</span>
</p>
<span id="close-addweixin-widget" class="iconfont iconfont-close"></span>
</div>
<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.7.07";

</script>
<script src="../templets/new/script/jquery1.12.4.min.js"></script>
<script src="https://c.biancheng.net/templets/new/script/common.js"></script>
<span style="display: none;">
<script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"KDf6QzBhogyQjall",ck:"KDf6QzBhogyQjall",autoTrack:true})</script>
</span>
</body>
</html>