<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="renderer" content="webkit" />
<meta name="force-rendering" content="webkit"/>
<meta name="applicable-device" content="pc,mobile" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="format-detection" content="telephone=no" />
<link rel="shortcut icon" href="../favicon.ico" />
<link href="../templets/new/style/common.css" rel="stylesheet" />
<title>Docker入门教程（简明版）</title>
<meta name="description" content="Docker 是目前最流行的一种容器平台，本教程将介绍 Docker 容器的初步使用。 如果你还不了解容器的概念，请转到： 容器是什么？ 1. Docker 简介 Docker 是一个用于开发、发布和运行应用程" />
</head>
<body>
<div id="topbar" class="clearfix">
<ul id="product-type" class="left">
<li>
<a href="../c_biancheng_default.html"><span class="iconfont iconfont-home"></span>首页</a>
</li>
<li class="active">
<a href="../sitemap/sitemap_3.html" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
</li>
<li>
<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
</li>
<li>
<a href="../fudao_biancheng_default.html" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
</li>
<li>
<a href="niz69i.html" target="_blank"><span class="iconfont iconfont-chip"></span>嵌入式学习路线</a>
</li>
</ul>
</div>
<div id="header" class="clearfix">
<a id="logo" class="left" href="../c_biancheng_default.html">
<img height="26" src="../templets/new/images/logo.png" alt="C语言中文网" />
</a>
<ul id="nav-main" class="hover-none left clearfix">
<li class="wap-yes"><a href="../c_biancheng_default.html">首页</a></li>
<li><a href="../c/c_3.html">C语言教程</a></li>
<li><a href="../cplus/cplus.html">C++教程</a></li>
<li><a href="../python/python.html">Python教程</a></li>
<li><a href="../java/java_3.html">Java教程</a></li>
<li><a href="../linux_tutorial/linux_tutorial.html">Linux入门</a></li>
<li><a href="../sitemap/sitemap_3.html" title="网站地图">更多&gt;&gt;</a></li>
</ul>
<a href="http://vip.biancheng.net/?from=topbar" class="user-info iconfont iconfont-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main-no-course" class="clearfix">
<div class="arc-info">
<span class="position"><span class="iconfont iconfont-home2"></span> <a href="../c_biancheng_default.html">首页</a> &gt; 编程笔记</span>
</div>
<div id="ggxc-position-bottom" class="ggxc-box"></div>
<h1>Docker入门教程（简明版）</h1>
<div id="ggxc-arctop-pc-1" class="ggxc-box"></div>
<div id="arc-body">Docker 是目前最流行的一种容器平台，本教程将介绍 Docker 容器的初步使用。<br />
<br />
如果你还不了解容器的概念，请转到：<a href="2ingx9.html" target="_blank">容器是什么？</a>
<h2>
1. Docker 简介</h2>
Docker 是一个用于开发、发布和运行应用程序的开放容器平台。Docker 能够将应用程序与基础架构分离，以便快速交付软件。<br />
<br />
使用 Docker，我们可以像管理应用程序一样管理基础架构。通过利用 Docker 快速发布、测试与部署代码的方法，我们能够显著提升编写代码与在生产环境运行代码的效率。
<h4>
1) Docker 的能力</h4>
Docker 提供在被称为容器的松散隔离环境中打包和运行应用程序的能力。容器是轻量的，其包含运行应用程序所需的一切，所以无须依赖主机当前安装的内容。<br />
<br />
Docker 的隔离性和安全性允许在同一主机同时运行多个容器。我们还可以在工作中共享容器，且能确保与我们共享容器的每个人获取的容器都能以相同方式工作。<br />
<br />
Docker 提供工具和平台来管理容器的生命周期，包括:
<ul>
<li>
使用容器来开发应用程序及其支持组件；</li>
<li>
容器称为分发和测试应用程序的单元；</li>
<li>
准备就绪后，将应用程序作为容器部署到生成环境而不论生成环境是本地数据中心还是云环境还是混合云。</li>
</ul>
<h4>
2. Docker 可用来做什么？</h4>
① 应用程序的持续快速交付<br />
<br />
Docker 为开发人员提供了标准的应用程序运行环境，从而简化了软件开发周期。并且，容器非常适合持续集成和持续交付工作流程，为应用程序的持续快速交付提供了保障。<br />
<br />
② 响应式部署和扩展<br />
<br />
Docker 的可移植性和轻量性使得工作负载的动态管理（按照业务需要近乎实时的扩展或销毁应用程序）变得容易。<br />
<br />
③ 同样的硬件上运行更多的工作负载<br />
<br />
Docker 轻量而快速，较虚拟机更经济高效，允许在同样的硬件资源上运行更多的工作负载。
<h2>
2. Docker 架构</h2>
Docker 使用的是 C/S（客户端-服务器）架构。<br />
<br />
<div style="text-align: center;">
<img alt="Docker 架构示意图" src="../uploads/allimg/230620/1-230620112013627.png" /><br />
图1：Docker 架构示意图</div>
<br />
Docker 客户端和 Docker 守护程序（负责构建、运行和分发 Docker 容器）使用 UNIX 套接字或网络接口之上的 REST API 进行通信。Docker 客户端与 Docker 守护程序可位于同一系统，也可以位于不同的系统上（Docker 客户端可连接远程的 Docker 守护程序）。Docker Compose 也算 Docker 客户端的一种，其允许处理多个容器组成的应用程序。
<h3>
1) Docker 守护程序</h3>
Docker 守护程序（dockerd）负责监听 Docker API 请求并管理 Docker 对象（镜像、容器、网络和卷等）。Docker 守护程序还可以与其它守护程序进行通信来管理 Docker 服务。
<h3>
2) Docker 客户端</h3>
Docker 客户端（docker）是与 Docker 交互的主要方式。当使用诸如docker run之类的命令时，Docker 客户端会使用 Docker API 调用守护程序dockerd，守护程序dockerd会处理这些命令。Docker 客户端可与多个守护程序进行通信。
<h3>
3) Docker 桌面</h3>
Docker 桌面是一个「全家桶」安装包，包含了 Docker 客户端、Docker 守护程序、Docker Compose、Kubernetes 和凭证助手等功能。
<h3>
4) Docker 镜像仓库</h3>
Docker 镜像仓库用于存储 Docker 镜像。Docker Hub 是一个所有人都可以使用的镜像仓库，也是 Docker 默认的镜像存储仓库。
<h3>
5) Docker 对象</h3>
我们使用 Docker 时，主要是使用镜像、容器、网络、卷或插件等 Docker 对象，下面会简单介绍下镜像和容器这两个对象。
<h4>
① 镜像</h4>
Docker 镜像是一个包含命令的创建 Docker 容器的只读模板。通常，一个镜像依赖另一个镜像并有一些额外的定制。<br />
<br />
创建自己的 Docker 镜像时，使用Dockerfile来定义构建与运行镜像的所需步骤。Dockerfile中的每条命令都会在镜像中创建一个层，当修改Dockerfile并重新构建镜像时，只有变化的层会被重新构建，这也是容器镜像比其它虚拟技术更轻量快速的原因。
<h4>
② 容器</h4>
容器是镜像的运行实例。我们可以使用 Docker 客户端或调用 Docker API 创建、启动、停止、移动或删除容器，可以为容器连接网络，给容器添加存储，甚至可以根据容器当前状态创建一个新镜像。<br />
<br />
默认情况下，容器与其它容器及主机是严格隔离的。当然，容器的网络、存储等与其它容器及主机的隔离程度是可以控制的。
<p class="tip-box">
补充说明：Docker 是使用 Go 语言编写的，且利用了 Linux 内核提供的特性。Docker 使用命名空间技术来提供容器的空间隔离。</p>
<h2>
3. Docker 安装</h2>
最直接快速安装 Docker 的方法就是安装 Docker 桌面。本教程使用的操作系统为 macOS，直接从<a href="https://docs.docker.com/get-docker/" target="_blank">官方网站</a>下载最新的版本，双击运行后「Accept」即可。
<h2>
4. Docker 的初步使用</h2>
<h4>
1) 容器化应用程序</h4>
下面使用一个 Node.js 编写的「待办列表」示例应用程序来演示 Docker 的使用。<br />
<br />
开始前，先将代码克隆下来：
<p class="info-box">
git clone https://github.com/docker/getting-started.git</p>
然后，可以看到 getting-started/app 文件夹下有两个子文件夹 src 和 spec，以及一个 package.json 文件。
<pre class="info-box">
getting-started
├─ app
│   ├─ src/
│   ├─ spec/
│   └─ package.json
└─ ...
</pre>
下面，在 getting-started/app 文件夹下新建一个 Dockerfile 文件，并为其添加如下内容：
<pre class="info-box">
# syntax=docker/dockerfile:1

FROM node:18-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD [&quot;node&quot;, &quot;src/index.js&quot;]
EXPOSE 3000</pre>
然后，在 getting-started/app 文件夹下执行 docker build 命令来构建镜像：
<pre class="info-box">
# -t 表示给镜像起一个名字
# . 表示在当前文件夹寻找 Dockerfile
docker build -t getting-started .</pre>
镜像构建完成后，使用 docker run 命令来启动容器：
<pre class="info-box">
# -d 表示以后台方式运行
# -p 表示使用主机的 3000 端口映射容器的 3000 端口
# getting-started 即是要运行的镜像名
docker run -dp 3000:3000 getting-started</pre>
这样，浏览器访问 http://localhost:3000 即可以看到应用程序了：<br />
<br />
<div style="text-align: center;">
<img alt="应用程序启动成功" src="../uploads/allimg/230620/1-230620113339A7.jpg" /><br />
图2：应用程序启动成功</div>
<br />
此外，还可以使用 docker ps 命令来查看容器状态，使用 docker stop 命令来停止容器，以及对停止的容器使用 docker rm 来进行移除。
<h4>
2) 镜像推送与分享</h4>
下面，尝试将镜像推送到「Docker Hub」。<br />
<br />
开始前，首先需要注册一个 Docker Hub 账号，我的账号为 olzhy。<br />
<br />
接着，使用 docker login 命令登录到 Docker Hub：
<p class="info-box">
docker login</p>
然后，使用 docker tag 命令将 getting-started 镜像重命名：
<p class="info-box">
docker tag getting-started olzhy/getting-started</p>
最后，使用 docker push 命令将镜像推送至 Docker Hub：
<p class="info-box">
docker push olzhy/getting-started</p>
这样，任何人即可以在安装了 Docker 的机器上使用我们刚刚推送的镜像了：
<p class="info-box">
docker run -dp 3000:3000 olzhy/getting-started</p>
<h4>
3) 数据库持久化</h4>
目前的这个「待办列表」示例应用程序重启后，数据会丢失。这是因为未对数据库进行持久化，下面看一下如何持久化数据库。<br />
<br />
卷（Volume）提供了将容器的特定文件系统路径映射到主机的功能。<br />
<br />
「待办列表」示例应用程序使用的是 SQLite 数据库，其数据存储在文件 /etc/todos/todo.db 中。<br />
<br />
下面，使用 docker volume create 命令创建一个卷：
<p class="info-box">
docker volume create todo-db</p>
然后，指定挂载的卷，并启动容器：
<p class="info-box">
docker run -dp 3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started</p>
启动完成后，增加一些数据。这时，停止并移除上述容器后，再次使用如上命令启动新的容器时，仍可以看到之前添加的数据。<br />
<br />
最后，使用 docker volume inspect 命令看一下数据到底存到了哪里：
<pre class="info-box">
docker volume inspect todo-db

[
    {
        &quot;CreatedAt&quot;: &quot;2023-05-21T02:27:07Z&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/todo-db/_data&quot;,
        &quot;Name&quot;: &quot;todo-db&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    }
]</pre>
挂载点（Mountpoint）显示了数据在主机的具体位置。<br />
<br />
除了使用卷外，还可以使用绑定挂载（Bind Mounts）来将主机的任一文件或文件夹挂载到容器。<br />
<br />
使用方式与卷类似，下面是使用 Bind Mounts 挂载方式运行容器的命令：
<p class="info-box">
docker run -dp 3000:3000 --mount type=bind,src=/tmp/todos,target=/etc/todos getting-started<br />
<br />
# 亦可以直接简化为 -v 方式<br />
docker run -dp 3000:3000 -v /tmp/todos:/etc/todos getting-started</p>
<h4>
4) 多容器应用</h4>
下面，新建一个 MySQL 数据库容器，然后尝试用「待办列表」容器连接这个数据库。<br />
<br />
两个容器需要使用网络进行通信，首先需要创建网络：
<p class="info-box">
docker network create todo-app</p>
接着，运行 MySQL 容器：
<pre class="info-box">
# 可以看到，挂载的时候，未创建卷 todo-mysql-data，这个时候 Docker 会自动帮我们创建
docker run -d \
     --network todo-app --network-alias mysql \
     -v todo-mysql-data:/var/lib/mysql \
     -e MYSQL_ROOT_PASSWORD=secret \
     -e MYSQL_DATABASE=todos \
     mysql:8.0</pre>
使用如下命令进入容器，尝试连接数据库并执行数据库命令：
<p class="info-box">
docker exec -it &lt;mysql-container-id&gt; mysql -u root -p</p>
<br />
<pre class="info-box">
mysql&gt; SHOW DATABASES;

+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| todos              |
+--------------------+
5 rows in set (0.00 sec)</pre>
可以看到，数据库todos已被创建。<br />
<br />
下面，进入 getting-started/app 文件夹，使用如下命令来启动「待办列表」容器：
<pre class="info-box">
docker run -dp 3000:3000 \
   -w /app -v &quot;$(pwd):/app&quot; \
   --network todo-app \
   -e MYSQL_HOST=mysql \
   -e MYSQL_USER=root \
   -e MYSQL_PASSWORD=secret \
   -e MYSQL_DB=todos \
   node:18-alpine \
   sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</pre>
访问应用程序，并增加一些条目。<br />
<br />
这时，查看数据库时，发现表里边已经写入了数据：
<p class="info-box">
docker exec -it &lt;mysql-container-id&gt; mysql -p todos</p>
<br />
<pre class="info-box">
mysql&gt; select * from todo_items;
+--------------------------------------+--------------------+-----------+
| id                                   | name               | completed |
+--------------------------------------+--------------------+-----------+
| c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! |         0 |
| 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome!        |         0 |
+--------------------------------------+--------------------+-----------+</pre>
<h4>
5) 使用 Docker Compose</h4>
上面，启动多个容器时，需要考虑新建网络、启动容器，暴露端口和指定环境变量等一系列步骤。而如果使用 Docker Compose 的话，就会变得很简单。<br />
<br />
Docker Compose 是一个定义多容器应用程序的工具。<br />
<br />
下面，在 getting-started/app 文件夹下创建一个名为 docker-compose.yml 的文件。<br />
<br />
然后，将如下内容填充到该文件中：
<pre class="info-box">
services:
  app:
    image: node:18-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:8.0
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:</pre>
可以看到，该 Compose 文件配置了应用程序和 MySQL 两个服务，配置参数非常的简单明了。<br />
<br />
接着，使用如下命令启动容器：
<p class="info-box">
docker compose up -d</p>
使用如下命令查看日志：
<p class="info-box">
docker compose logs -f</p>
测试完成后，可使用如下命令移除容器：
<p class="info-box">
# 若要将 Volume 一并移除，需要加 --volumes 标记<br />
docker compose down</p>
<h2>
5. 镜像构建最佳实践</h2>
<h4>
1) 利用镜像分层缓存加快构建速度</h4>
基于 Dockerfile 进行镜像构建时，一旦某一层发生变化，后面的步骤都需要重新构建。<br />
<br />
看一下前面构建「待办列表」应用程序的 Dockerfile 文件：
<pre class="info-box">
# syntax=docker/dockerfile:1
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD [&quot;node&quot;, &quot;src/index.js&quot;]</pre>
其存在几个问题：
<ul>
<li>
COPY 时，未指定应当忽略的文件夹，node_modules会被拷贝进去；</li>
<li>
任何文件有修改时，都需要重新进行yarn install。</li>
</ul>
<br />
下面，在当前文件夹下新建一个 .dockerignore 文件，并添加如下内容：
<p class="info-box">
node_modules</p>
表示 COPY 时，忽略 node_modules 文件夹。<br />
<br />
接着，对 Dockerfile 文件进行一下改造，改造后的内容如下：
<pre class="info-box">
# syntax=docker/dockerfile:1
FROM node:18-alpine
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --production
COPY . .
CMD [&quot;node&quot;, &quot;src/index.js&quot;]</pre>
改造的思路是：yarn install 主要依赖 package.json 文件，所以将这两步放到一块，这样只要不改 package.json 这个文件，就不用重新进行 yarn install。<br />
<br />
经过改造后，较之前会大大节省镜像的构建时间。
<h4>
2) 利用多阶段构建减小镜像体积</h4>
多阶段构建可以将构建时依赖项与运行时依赖项分开，并且可以通过仅提供运行所需的内容来减小镜像的体积。<br />
<br />
下面用两个具体的例子来说明如何进行多阶段构建。<br />
<br />
一个是 Maven/Tomcat 应用程序的例子：当构建一个使用 Maven 管理的 Java 应用程序时，JDK 和 Maven 是必需的；而在运行时，JDK 和 Maven 却不是必需的。这时就可以使用多阶段构建来帮忙了。<br />
<br />
针对该应用程序，使用多阶段构建的Dockerfile文件内容可以是如下这样：
<pre class="info-box">
# syntax=docker/dockerfile:1
FROM maven AS build
WORKDIR /app
COPY . .
RUN mvn package

FROM tomcat
COPY --from=build /app/target/file.war /usr/local/tomcat/webapps</pre>
可以看到，第一个阶段（build）基于 Maven 环境将 Java 源码编译为一个 war 包；第二个阶段准备了一个 Tomcat 环境，然后将第一个阶段生成的 war 包拷贝到对应位置。最终的镜像只有 Tomcat 这个阶段的部分，省去了很多没必要的依赖。<br />
<br />
另一个是 React 应用程序的例子：当构建 React 应用程序时，需要依赖 Node.js 环境来编译 JSX 源码文件和 SASS 样式文件；而在运行时，可以不依赖 Node.js 环境，直接使用 Nginx 容器 Serve 这些静态文件即可。<br />
<br />
针对该应用程序，使用多阶段构建的Dockerfile文件内容可以是如下这样：
<pre class="info-box">
# syntax=docker/dockerfile:1
FROM node:18 AS build
WORKDIR /app
COPY package* yarn.lock ./
RUN yarn install
COPY public ./public
COPY src ./src
RUN yarn run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html</pre>
可以看到，第一个阶段（build）基于 Node.js 环境将 JSX 源码文件和 SASS 样式文件编译为 HTML、JS 和 CSS 静态文件；第二个阶段仅需要一个 Nginx 环境，然后将第一个阶段生成的静态文件拷贝到对应目录。<br />
<br />
综上所述，本教程完成了对 Docker 的简单使用。阅读完本教程，大家对 Docker 是什么、Docker 能做什么、Docker 的架构是什么样的以及 Docker 怎么使用都有了一个基本的了解。<br />
</div>
<div id="ggxc-weixin-arcbottom">
<p>关注公众号「<span class="col-green">站长严长生</span>」，在手机上阅读所有教程，随时随地都能学习。内含一款搜索神器，免费下载全网书籍和视频。</p>
<p style="margin-top:12px; text-align:center;">
<img src="../templets/new/images/material/qrcode_mp.png" alt="公众号二维码" width="160" /><br />
<span class="col-green">微信扫码关注公众号</span>
</p>
</div>
<div id="nice-arcs" class="box-bottom">
<h4>推荐阅读</h4>
<ul class="clearfix">
<li><a href="niz69i_4.html" title="一套完整的嵌入式开发学习路线（高薪就业版）" target="_blank">一套完整的嵌入式开发学习路线（高薪就业版）</a></li>
<li><a href="tnnfqo_2.html" title="一套课程卖1万，TMD太贵了！" target="_blank">一套课程卖1万，TMD太贵了！</a></li>
<li><a href="unnurw_2.html" title="跑了3000公里，见了一位大佬" target="_blank">跑了3000公里，见了一位大佬</a></li>
<li><a href="386.html" title="C++ multiset，STL multiset详解" target="_blank">C++ multiset，STL multiset详解</a></li>
<li><a href="5668.html" title="JS截取数组：使用splice()和slice()方法" target="_blank">JS截取数组：使用splice()和slice()方法</a></li>
<li><a href="7381.html" title="MySQL恢复数据库（mysql命令）" target="_blank">MySQL恢复数据库（mysql命令）</a></li>
<li><a href="../csharp/data-type-conversion.html" title="C#数据类型转换" target="_blank">C#数据类型转换</a></li>
<li><a href="7io8p5.html" title="C-V2X车联网技术介绍（非常详细）" target="_blank">C-V2X车联网技术介绍（非常详细）</a></li>
<li><a href="vinzwl.html" title="Python判断输入的字符串是否是回文（不区分大小写）" target="_blank">Python判断输入的字符串是否是回文（不区分大小写）</a></li>
<li><a href="../c/log2.html" title="C语言log2()：返回x的自然对数（以2为底的对数）" target="_blank">C语言log2()：返回x的自然对数（以2为底的对数）</a></li>
</ul>
</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 9964;
window.arcId = "1c4fv5+r7cYhFJ7fZbArRnFyHDqe/XAQgZlALxvDJT9q45mxxeXOF5RYRK4";
window.typeidChain = "119";
</script>
<div id="footer" class="clearfix">
<div class="info left">
<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
<p>
<a href="8066.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
<a href="8092_2.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
<a href="8097.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
<a href="9648.html" target="_blank" rel="nofollow">公众号</a> <span>|</span>
<a href="8093.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
<a href="../sitemap/sitemap_3.html" target="_blank" rel="nofollow">网站地图</a>
</p>
<p>Copyright ©2012-2022 biancheng.net, <a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow" style="color:#666;">冀ICP备2022013920号</a>, <img height="13" src="../templets/new/images/gongan.png" alt="公安备案图标" /><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13110202001352" target="_blank" rel="nofollow" style="color:#666;">冀公网安备13110202001352号</a>
</p>
</div>
<img id="logo_bottom" class="right" src="https://c.biancheng.net/templets/new/images/logo_bottom.gif" alt="底部Logo" />
<span id="return-top"><b>↑</b></span>
</div>
<div id="addweixin-widget">
<p>
<script type="text/javascript">
			/*var suffix = 'c';
			var thisMin = (new Date()).getMinutes();
			if(thisMin>=40){
				suffix = 'd';
			}else if(thisMin>=20){
				suffix = 'e';
			}else{
				suffix = 'c';
			}
			document.write('<img src="https://c.biancheng.net/templets/new/images/material/qrcode_wx_'%20+%20suffix%20+'.png?v=1.7.07" alt="微信交流群" width="120" /><br />');*/
		</script>
<img src="../templets/new/images/material/qrcode_mp_2.png" alt="微信交流群" width="120" />
<span>关注微信公众号，加入官方交流群。内含一款搜索神器，免费下载全网书籍和视频。</span>
</p>
<span id="close-addweixin-widget" class="iconfont iconfont-close"></span>
</div>
<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.7.07";

</script>
<script src="../templets/new/script/jquery1.12.4.min.js"></script>
<script src="https://c.biancheng.net/templets/new/script/common.js"></script>
<span style="display: none;">
<script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"KDf6QzBhogyQjall",ck:"KDf6QzBhogyQjall",autoTrack:true})</script>
</span>
</body>
</html>