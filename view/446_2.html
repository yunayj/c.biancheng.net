<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<!-- 启用Chromium高速渲染模式 -->
<meta name="renderer" content="webkit" />
<meta name="force-rendering" content="webkit"/>
<!-- 禁止百度转码 -->
<meta name="applicable-device" content="pc,mobile" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<!-- 禁止识别电话号码 -->
<meta name="format-detection" content="telephone=no" />

<link rel="shortcut icon" href="../favicon_3.ico" />
<link href="../templets/new/style/common_2.css" rel="stylesheet" />
<title>C语言宏的定义和宏的使用方法（#define）</title>
<meta name="description" content="在 C 语言中，可以采用命令 #define 来定义宏。该命令允许把一个名称指定成任何所需的文本，例如一个常量值或者一条语句。在定义了宏之后，无论宏名称出现在源代码的何处，预处理" />
</head>
<body>
<div id="topbar" class="clearfix">
	<ul id="product-type" class="left">
		<li>
			<a href="../m_biancheng_default_2.html"><span class="iconfont iconfont-home"></span>首页</a>
		</li>
		<li class="active">
			<a href="../sitemap/sitemap_2.html" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
		</li>
		<li>
			<a href="../fudao_biancheng_default.html" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
		</li>
		<li>
			<a href="niz69i_5.html" target="_blank"><span class="iconfont iconfont-chip"></span>嵌入式学习路线</a>
		</li>
		<!-- <li>
			<a href="https://www.54benniao.com/c_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-c-course"></span>C语言高级课程</a>
		</li>
		<li>
			<a href="https://www.54benniao.com/java_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-java-course"></span>Java高级课程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/q2a/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-q2a"></span>一对一答疑</a>
		</li> -->
	</ul>
</div>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="../m_biancheng_default_2.html">
		<img height="26" src="../templets/new/images/logo_2.png" alt="C语言中文网" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li class="wap-yes"><a href="../m_biancheng_default_2.html">首页</a></li>
		<li><a href="../c/c_4.html">C语言教程</a></li>
		<li><a href="../cplus/cplus_2.html">C++教程</a></li>
		<li><a href="../python/python_2.html">Python教程</a></li>
		<li><a href="../java/java_2.html">Java教程</a></li>
		<li><a href="../linux_tutorial/linux_tutorial_2.html">Linux入门</a></li>
		<li><a href="../sitemap/sitemap_2.html" title="网站地图">更多&gt;&gt;</a></li>
	</ul>
	<a href="http://vip.biancheng.net/?from=topbar" class="user-info iconfont iconfont-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main-no-course" class="clearfix">
	<div class="arc-info">
		<span class="position"><span class="iconfont iconfont-home2"></span> <a href="../m_biancheng_default_2.html">首页</a> &gt; 编程笔记</span>
	</div>
	<div id="ggxc-position-bottom" class="ggxc-box"></div>
	<h1>C语言宏的定义和宏的使用方法（#define）</h1>
	<div id="ggxc-arctop-pc-1" class="ggxc-box"></div>
	<div id="arc-body"><span style="color:#b22222;">在 C 语言中，可以采用命令 #define 来定义宏。</span>该命令允许把一个名称指定成任何所需的文本，例如一个常量值或者一条语句。在定义了宏之后，无论宏名称出现在源代码的何处，预处理器都会把它用定义时指定的文本替换掉。<br />
<br />
关于宏的一个常见应用就是，用它定义数值常量的名称：
<pre class="cpp">
#define         ARRAY_SIZE 100
double   data[ARRAY_SIZE];</pre>
这两行代码为值 100 定义了一个宏名称 ARRAY_SIZE，并且在数组 data 的定义中使用了该宏。<span style="color:#b22222;">惯例将宏名称每个字母采用大写，这有助于区分宏与一般的变量。</span>上述简单的示例也展示了宏是怎样让 C 程序更有弹性的。<br />
<br />
通常情况下，程序中往往多次用到数组（例如上述 data）的长度，例如，采用数组元素来控制 for 循环遍历次数。当每次用到数组长度时，用宏名称而不要直接用数字，如果程序的维护者需要修改数组长度，只需要修改宏的定义即可，即 #define 命令，而不需要修改程序中每次用到每个数组长度的地方。<br />
<br />
在翻译的第三个步骤中，预处理器会分析源文件，把它们转换为预处理器记号和空白符。如果遇到的记号是宏名称，预处理器就会展开（expand）该宏；也就是说，会用定义的文本来取代宏名称。<span style="color:#b22222;">出现在字符串字面量中的宏名称不会被展开，因为整个字符串字面量算作一个预处理器记号。</span><br />
<br />
<span style="color:#b22222;">无法通过宏展开的方式创建预处理器命令。</span>即使宏的展开结果会生成形式上有效的命令，但预处理器不会执行它。<br />
<br />
在宏定义时，可以有参数，也可以没有参数。
<h2>
	没有参数的宏</h2>
<span style="color:#b22222;">没有参数的宏定义</span>，采用如下形式：
<pre class="cpp">
#define 宏名称 替换文本</pre>
<br />
&ldquo;替换文本&rdquo;前面和后面的空格符不属于替换文本中的内容。<span style="color:#b22222;">替代文本本身也可以为空。</span>下面是一些示例：
<pre class="cpp">
#define TITLE &quot;*** Examples of Macros Without Parameters ***&quot;
#define BUFFER_SIZE (4 * 512)
#define RANDOM (-1.0 + 2.0*(double)rand() / RAND_MAX)</pre>
<br />
标准函数 rand（）返回一个伪随机整数，范围在 [0，RAND_MAX] 之间。rand（）的原型和 RAND_MAX 宏都定义在标准库头文件 stdlib.h 中。<br />
<br />
下面的语句展示了上述宏的一种可能使用方式：
<pre class="cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
/* ... */
// 显示标题
puts( TITLE );

// 将流fp设置成&ldquo;fully buffered&rdquo;模式，其具有一个缓冲区，
// 缓冲区大小为BUFFER_SIZE个字节
// 宏_IOFBF在stdio.h中定义为0
static char myBuffer[BUFFER_SIZE];
setvbuf( fp, myBuffer, _IOFBF, BUFFER_SIZE );

// 用ARRAY_SIZE个[-10.0, +10.0]区间内的随机数值填充数组data
for ( int i = 0; i &lt; ARRAY_SIZE; ++i )
  data[i] = 10.0 * RANDOM;</pre>
<br />
用替换文本取代宏，预处理器生成下面的语句：
<pre class="cpp">
puts( &quot;*** Examples of Macros Without Parameters ***&quot; );

static char myBuffer[(4 * 512)];
setvbuf( fp, myBuffer, 0, (4 * 512) );

for ( int i = 0; i &lt; 100; ++i )
data[i] = 10.0 * (-1.0 + 2.0*(double)rand() / 2147483647);</pre>
<br />
在上例中，该实现版本中的 RAND_MAX 宏值是 2147483647。如果采用其他的编译器，RAND_MAX 的值可能会不一样。<br />
<br />
如果编写的宏中包含了一个有操作数的表达式，应该把表达式放在圆括号内，以避免使用该宏时受运算符优先级的影响，进而产生意料之外的结果。例如，RANDOM 宏最外侧的括号可以确保 10.0*RANDOM 表达式产生想要的结果。如果没有这个括号，宏展开后的表达式变成：
<pre class="cpp">
10.0 * -1.0 + 2.0*(double)rand() / 2147483647</pre>
<br />
这个表达式生成的随机数值范围在 [-10.0，-8.0] 之间。
<h2>
	带参数的宏</h2>
你可以定义具有形式参数（简称&ldquo;形参&rdquo;）的宏。当预处理器展开这类宏时，它先使用调用宏时指定的实际参数（简称&ldquo;实参&rdquo;）取代替换文本中对应的形参。<span style="color:#b22222;">带有形参的宏通常也称为类函数宏（function-like macro）。</span><br />
<br />
可以使用下面两种方式定义带有参数的宏：
<pre class="cpp">
#define 宏名称( [形参列表] ) 替换文本
#define 宏名称( [形参列表 ,] ... ) 替换文本</pre>
<br />
<span style="color:#b22222;">&ldquo;形参列表&rdquo;是用逗号隔开的多个标识符，它们都作为宏的形参。当使用这类宏时，实参列表中的实参数量必须与宏定义中的形参数量一样多</span>（然而，C99 允许使用&ldquo;空实参&rdquo;，下面会进一步解释）。这里的省略号意味着一个或更多的额外形参。<br />
<br />
<span style="color:#b22222;">当定义一个宏时，必须确保宏名称与左括号之间没有空白符。</span>如果在名称后面有任何空白，那么命令就会把宏作为没有参数的宏，且从左括号开始采用替换文本。<br />
<br />
常见的两个函数 getchar（）和 putchar（），它们的宏定义在标准库头文件 stdio.h 中。它们的展开值会随着实现版本不同而有所不同，但不论何种版本，它们的定义总是类似于以下形式：
<pre class="cpp">
#define getchar() getc(stdin)
#define putchar(x) putc(x, stdout)</pre>
<br />
当&ldquo;调用&rdquo;一个类函数宏时，预处理器会用调用时的实参取代替换文本中的形参。C99 允许在调用宏的时候，宏的实参列表可以为空。在这种情况下，对应的替换文本中的形参不会被取代；也就是说，替换文本会删除该形参。然而，并非所有的编译器都支持这种&ldquo;空实参&rdquo;的做法。<br />
<br />
如果调用时的实参也包含宏，在正常情况下会先对它进行展开，然后才把该实参取代替换文本中的形参。对于替换文本中的形参是 # 或 ## 运算符操作数的情况，处理方式会有所不同。下面是类函数宏及其展开结果的一些示例：
<pre class="cpp">
#include &lt;stdio.h&gt;             // 包含putchar()的定义
#define DELIMITER &#39;:&#39;
#define SUB(a,b) (a-b)
putchar( DELIMITER );
putchar( str[i] );
int var = SUB( ,10);</pre>
<br />
如果 putchar（x）定义为 putc（x，stdout），预处理器会按如下方式展开最后三行代码：
<pre class="cpp">
putc(&#39;:&#39;, stdout);
putc(str[i], stdout);
int var = (-10);</pre>
<br />
如下例所示，<span style="color:#b22222;">替换文本中所有出现的形参，应该使用括号将其包围。</span>这样可以确保无论实参是否是表达式，都能正确地被计算：
<pre class="cpp">
#define DISTANCE( x, y ) ((x)&gt;=(y) ? (x)-(y) : (y)-(x))
d = DISTANCE( a, b+0.5 );</pre>
<br />
该宏调用展开如下所示：
<pre class="cpp">
d = ((a)&gt;=(b+0.5) ? (a)-(b+0.5) : (b+0.5)-(a));</pre>
如果 x 与 y 没有采用括号，那么扩展后将出现表达式 a-b+0.5，而不是表达式（a）-（b+0.5），这与期望的运算不同。
<h4>
	可选参数</h4>
C99 标准允许定义有省略号的宏，省略号必须放在参数列表的后面，以表示可选参数。你可以用可选参数来调用这类宏。<br />
<br />
当调用有可选参数的宏时，预处理器会将所有可选参数连同分隔它们的逗号打包在一起作为一个参数。在替换文本中，标识符 __VA_ARGS__ 对应一组前述打包的可选参数。<span style="color:#b22222;">标识符 __VA_ARGS__ 只能用在宏定义时的替换文本中。</span><br />
<br />
__VA_ARGS__ 的行为和其他宏参数一样，唯一不同的是，它会被调用时所用的参数列表中剩下的所有参数取代，而不是仅仅被一个参数取代。下面是一个可选参数宏的示例：
<pre class="cpp">
// 假设我们有一个已打开的日志文件，准备采用文件指针fp_log对其进行写入
#define printLog(...) fprintf( fp_log, __VA_ARGS__ )
// 使用宏printLog
printLog( &quot;%s: intVar = %d\n&quot;, __func__, intVar );</pre>
<br />
预处理器把最后一行的宏调用替换成下面的一行代码：
<pre class="cpp">
fprintf( fp_log, &quot;%s: intVar = %d\n&quot;, __func__, intVar );</pre>
<br />
<span style="color:#b22222;">预定义的标识符 __func__ 可以在任一函数中使用，该标识符是表示当前函数名的字符串。</span>因此，该示例中的宏调用会将当前函数名和变量 intVar 的内容写入日志文件。
<h4>
	字符串化运算符</h4>
一元运算符 # 常称为<span style="color:#006400;">字符串化运算符（stringify operator 或 stringizing operator）</span>，因为它会把宏调用时的实参转换为字符串。<span style="color:#b22222;"># 的操作数必须是宏替换文本中的形参。</span>当形参名称出现在替换文本中，并且具有前缀 # 字符时，预处理器会把与该形参对应的实参放到一对双引号中，形成一个字符串字面量。<br />
<br />
<span style="color:#b22222;">实参中的所有字符本身维持不变</span>，但下面几种情况是例外：<br />
(1) 在实参各记号之间如果存在有空白符序列，都会被替换成一个空格符。<br />
(2) 实参中每个双引号（&quot;）的前面都会添加一个反斜线（\）。<br />
(3) 实参中字符常量、字符串字面量中的每个反斜线前面，也会添加一个反斜线。但如果该反斜线本身就是通用字符名的一部分，则不会再在其前面添加反斜线。<br />
<br />
下面的示例展示了如何使用#运算符，使得宏在调用时的实参可以在替换文本中同时作为字符串和算术表达式：
<pre class="cpp">
#define printDBL( exp ) printf( #exp &quot; = %f &quot;, exp )
printDBL( 4 * atan(1.0));           // atan()在math.h中定义</pre>
<br />
上面的最后一行代码是宏调用，展开形式如下所示：
<pre class="cpp">
printf( &quot;4 * atan(1.0)&quot; &quot; = %f &quot;, 4 * atan(1.0));</pre>
<br />
因为编译器会合并紧邻的字符串字面量，上述代码等效为：
<pre class="cpp">
printf( &quot;4 * atan(1.0) = %f &quot;, 4 * atan(1.0));</pre>
<br />
该语句会生成下列文字并在控制台输出：
<pre class="cpp">
4 * atan(1.0) = 3.141593</pre>
<br />
在下面的示例中，调用宏 showArgs 以演示 # 运算符如何修改宏实参中空白符、双引号，以及反斜线：
<pre class="cpp">
#define showArgs(...) puts(#__VA_ARGS__)
showArgs( one\n,       &quot;2\n&quot;, three );</pre>
<br />
预处理器使用下面的文本来替换该宏：
<pre class="cpp">
puts(&quot;one\n, \&quot;2\\n\&quot;, three&quot;);</pre>
<br />
该语句生成下面的输出：
<pre class="cpp">
one
, &quot;2\n&quot;, three</pre>
<h4>
	记号粘贴运算符</h4>
运算符是一个二元运算符，可以出现在所有宏的替换文本中。该运算符会把左、右操作数结合在一起，作为一个记号，因此，它常常被称为记号<span style="color:#006400;">粘贴运算符（token-pasting operator）</span>。如果结果文本中还包含有宏名称，则预处理器会继续进行宏替换。出现在 ## 运算符前后的空白符连同 ## 运算符本身一起被删除。<br />
<br />
<span style="color:#b22222;">通常，使用 ## 运算符时，至少有一个操作数是宏的形参。</span>在这种情况下，实参值会先替换形参，然后等记号粘贴完成后，才进行宏展开。如下例所示：
<pre class="cpp">
#define TEXT_A &quot;Hello, world!&quot;
#define msg(x) puts( TEXT_ ## x )
msg(A);</pre>
<br />
无论标识符 A 是否定义为一个宏名称，预处理器会先将形参 x 替换成实参 A，然后进行记号粘贴。当这两个步骤做完后，结果如下：
<pre class="cpp">
puts( TEXT_A );</pre>
<br />
现在，因为 TEXT_A 是一个宏名称，后续的宏替换会生成下面的语句：
<pre class="cpp">
puts( &quot;Hello, world!&quot; );</pre>
<br />
如果宏的形参是 ## 运算符的操作数，并且在某次宏调用时，并没有为该形参准备对应的实参，那么预处理使用占位符（placeholder）表示该形参被空字符串取代。<span style="color:#b22222;">把一个占位符和任何记号进行记号粘贴操作的结果还是原来的记号。</span>如果对两个占位符进行记号粘贴操作，则得到一个占位符。<br />
<br />
当所有的记号粘贴运算都做完后，预处理器会删除所有剩下的占位符。下面是一个示例，调用宏时传入空的实参：
<pre class="cpp">
msg();</pre>
<br />
这个调用会被展开为如下所示的代码：
<pre class="cpp">
puts( TEXT_ );</pre>
如果TEXT_不是一个字符串类型的标识符，编译器会生成一个错误信息。<br />
<br />
<span style="color:#b22222;">字符串化运算符和记号粘贴运算符并没有固定的运算次序。</span>如果需要采取特定的运算次序，可以将一个宏分解为多个宏。
<h2>
	在宏内使用宏</h2>
在替换实参，以及执行完 # 和 ## 运算之后，预处理器会检查操作所得的替换文本，并展开其中包含的所有宏。但是，宏不可以递归地展开：如果预处理器在 A 宏的替换文本中又遇到了 A 宏的名称，或者从嵌套在 A 宏内的 B 宏内又遇到了 A 宏的名称，那么 A 宏的名称就会无法展开。<br />
<br />
类似地，即使展开一个宏生成有效的命令，这样的命令也无法执行。然而，预处理器可以处理在完全展开宏后出现 _Pragma 运算符的操作。<br />
<br />
下面的示例程序以表格形式输出函数值：
<pre class="cpp">
// fn_tbl.c: 以表格形式输出一个函数的值。该程序使用了嵌套的宏
// -------------------------------------------------------------
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;                          // 函数cos()和exp()的原型

#define PI              3.141593
#define STEP    (PI/8)
#define AMPLITUDE       1.0
#define ATTENUATION     0.1                      // 声波传播的衰减指数
#define DF(x)   exp(-ATTENUATION*(x))
#define FUNC(x) (DF(x) * AMPLITUDE * cos(x)) // 震动衰减

// 针对函数输出：
#define STR(s) #s
#define XSTR(s) STR(s)                   // 将宏s展开，然后字符串化
int main()
{
  double x = 0.0;
  printf( &quot;\nFUNC(x) = %s\n&quot;, XSTR(FUNC(x)) );          // 输出该函数
  printf(&quot;\n %10s %25s\n&quot;, &quot;x&quot;, STR(y = FUNC(x)) );             // 表格的标题
  printf(&quot;-----------------------------------------\n&quot;);

  for ( ; x &lt; 2*PI + STEP/2; x += STEP )
    printf( &quot;%15f %20f\n&quot;, x, FUNC(x) );
  return 0;
}</pre>
<br />
该示例输出下面的表格：
<pre class="cpp">
FUNC(x) = (exp(-0.1*(x)) * 1.0 * cos(x))
          x                 y = FUNC(x)
-----------------------------------------
              0.000000          1.000000
              0.392699          0.888302
...
          5.890487              0.512619
          6.283186              0.533488</pre>
<h2>
	宏的作用域和重新定义</h2>
你<span style="color:#b22222;">无法再次使用 #define 命令重新定义一个已经被定义为宏的标识符，除非重新定义所使用的替换文本与已经被定义的替换文本完全相同。</span>如果该宏具有形参，重新定义的形参名称也必须与已定义形参名称的一样。<br />
<br />
如果想改变一个宏的内容，必须首先使用下面的命令取消现在的定义：
<pre class="cpp">
#undef 宏名称</pre>
<br />
执行上面的命令之后，标识符&ldquo;宏名称&rdquo;可以再次在新的宏定义中使用。如果上面指定的标识符并非一个已定义的宏名称，那么预处理器会忽略这个 #undef 命令。<br />
<br />
标准库中的多个函数名称也被定义成了宏。如果想直接调用这些函数，而不是调用同名称的宏，可以使用 #undef 命令取消对这些宏的定义。即使准备取消定义的宏是带有参数的，也不需要在 #undef 命令中指定参数列表。如下例所示：
<pre class="cpp">
#include &lt;ctype.h&gt;
#undef isdigit          // 移除任何使用该名称的宏定义
/* ... */
if ( isdigit(c) )               // 调用函数isdigit()
/* ... */</pre>
<br />
<span style="color:#b22222;">当某个宏首次遇到它的 #undef 命令时，它的作用域就会结束。如果没有关于该宏的 #undef 命令，那么它的作用域在该翻译单元结束时终止。</span></div>
	<div id="ggxc-weixin-arcbottom">
	<p>关注公众号「<span class="col-green">站长严长生</span>」，在手机上阅读所有教程，随时随地都能学习。内含一款搜索神器，免费下载全网书籍和视频。</p>
	<p style="margin-top:12px; text-align:center;">
		<img src="../templets/new/images/material/qrcode_mp_4.png" alt="公众号二维码" width="160" /><br />
		<span class="col-green">微信扫码关注公众号</span>
	</p>
</div>
	<div id="nice-arcs" class="box-bottom">
    <h4>推荐阅读</h4>
    <ul class="clearfix">
<li><a href="niz69i_8.html" title="一套完整的嵌入式开发学习路线（高薪就业版）" target="_blank">一套完整的嵌入式开发学习路线（高薪就业版）</a></li>
<li><a href="tnnfqo_4.html" title="一套课程卖1万，TMD太贵了！" target="_blank">一套课程卖1万，TMD太贵了！</a></li>
<li><a href="unnurw_4.html" title="跑了3000公里，见了一位大佬" target="_blank">跑了3000公里，见了一位大佬</a></li>
<li><a href="250_2.html" title="C++继承和派生是什么意思（通俗易懂）" target="_blank">C++继承和派生是什么意思（通俗易懂）</a></li>
<li><a href="417_2.html" title="C++ vector容量和大小" target="_blank">C++ vector容量和大小</a></li>
<li><a href="583_2.html" title="C语言兔子生兔子问题" target="_blank">C语言兔子生兔子问题</a></li>
<li><a href="3455_2.html" title="最佳归并树详解" target="_blank">最佳归并树详解</a></li>
<li><a href="6467_2.html" title="SNMP协议是什么？" target="_blank">SNMP协议是什么？</a></li>
<li><a href="8003_2.html" title="Django用户认证系统权限管理" target="_blank">Django用户认证系统权限管理</a></li>
<li><a href="../css3/box-sizing_2.html" title="CSS box-sizing：改变盒子模型" target="_blank">CSS box-sizing：改变盒子模型</a></li>
</ul>
</div>
	
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 446;
window.arcId = "40ce+V+fP5hZFl+wR0I5uICLy1nfwWE4epqUpDrzDe8rxWLpfSU2y6heOA";
window.typeidChain = "131|119";
</script>
<div id="footer" class="clearfix">
	<div class="info left">
	<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
	<p>
		<a href="8066_2.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
		<a href="8092_3.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
		<a href="8097_2.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
		<a href="9648_2.html" target="_blank" rel="nofollow">公众号</a> <span>|</span>
		<a href="8093_2.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
		<a href="../sitemap/sitemap_2.html" target="_blank" rel="nofollow">网站地图</a>
	</p>
	<p>Copyright ©2012-2022 biancheng.net, <a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow" style="color:#666;">冀ICP备2022013920号</a>, <img height="13" src="../templets/new/images/gongan_2.png" alt="公安备案图标" /><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13110202001352" target="_blank" rel="nofollow" style="color:#666;">冀公网安备13110202001352号</a>
	</p>
	</div>
	<img id="logo_bottom" class="right" src="https://m.biancheng.net/templets/new/images/logo_bottom_2.gif" alt="底部Logo" />
	<span id="return-top"><b>↑</b></span>
</div>

<div id="addweixin-widget">
	<p>
		<script type="text/javascript">
			/*var suffix = 'c';
			var thisMin = (new Date()).getMinutes();
			if(thisMin>=40){
				suffix = 'd';
			}else if(thisMin>=20){
				suffix = 'e';
			}else{
				suffix = 'c';
			}
			document.write('<img src="https://m.biancheng.net/templets/new/images/material/qrcode_wx_'%20+%20suffix%20+'.png?v=1.7.07" alt="微信交流群" width="120" /><br />');*/
		</script>
		<img src="https://m.biancheng.net/templets/new/images/material/qrcode_mp_4.png" alt="微信交流群" width="120" />
		<span>关注微信公众号，加入官方交流群。内含一款搜索神器，免费下载全网书籍和视频。</span>
	</p>
	<span id="close-addweixin-widget" class="iconfont iconfont-close"></span>
</div>

<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.7.07";

</script>

<script src="https://m.biancheng.net/templets/new/script/jquery1.12.4.min_2.js"></script>
<script src="https://m.biancheng.net/templets/new/script/common_2.js"></script>
<!-- 51la V6 -->
<span style="display: none;">
<script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"KDf6QzBhogyQjall",ck:"KDf6QzBhogyQjall",autoTrack:true})</script>
</span>
<!-- 51la V5 -->
<!-- <span style="display: none;"><script type="text/javascript" src="https://js.users.51.la/21368967.js"></script></span> -->
</body>
</html>