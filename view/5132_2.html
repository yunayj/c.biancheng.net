<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<!-- 启用Chromium高速渲染模式 -->
<meta name="renderer" content="webkit" />
<meta name="force-rendering" content="webkit"/>
<!-- 禁止百度转码 -->
<meta name="applicable-device" content="pc,mobile" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<!-- 禁止识别电话号码 -->
<meta name="format-detection" content="telephone=no" />

<link rel="shortcut icon" href="../favicon_3.ico" />
<link href="../templets/new/style/common_2.css" rel="stylesheet" />
<title>Go语言inject库：依赖注入</title>
<meta name="description" content="前面己经对反射的基本概念和相关 API 进行了讲解，本节结合一个非常著名的包 inject 展开讲解，inject 借助反射提供了对 2 种类型实体的注入：函数和结构。Go 著名的 Web 框架 martini 的依" />
</head>
<body>
<div id="topbar" class="clearfix">
	<ul id="product-type" class="left">
		<li>
			<a href="../m_biancheng_default_2.html"><span class="iconfont iconfont-home"></span>首页</a>
		</li>
		<li class="active">
			<a href="../sitemap/sitemap_2.html" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
		</li>
		<li>
			<a href="../fudao_biancheng_default.html" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
		</li>
		<li>
			<a href="niz69i_5.html" target="_blank"><span class="iconfont iconfont-chip"></span>嵌入式学习路线</a>
		</li>
		<!-- <li>
			<a href="https://www.54benniao.com/c_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-c-course"></span>C语言高级课程</a>
		</li>
		<li>
			<a href="https://www.54benniao.com/java_course/?from=biancheng" target="_blank"><span class="iconfont iconfont-java-course"></span>Java高级课程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/q2a/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-q2a"></span>一对一答疑</a>
		</li> -->
	</ul>
</div>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="../m_biancheng_default_2.html">
		<img height="26" src="../templets/new/images/logo_2.png" alt="C语言中文网" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li class="wap-yes"><a href="../m_biancheng_default_2.html">首页</a></li>
		<li><a href="../c/c_4.html">C语言教程</a></li>
		<li><a href="../cplus/cplus_2.html">C++教程</a></li>
		<li><a href="../python/python_2.html">Python教程</a></li>
		<li><a href="../java/java_2.html">Java教程</a></li>
		<li><a href="../linux_tutorial/linux_tutorial_2.html">Linux入门</a></li>
		<li><a href="../sitemap/sitemap_2.html" title="网站地图">更多&gt;&gt;</a></li>
	</ul>
	<span id="sidebar-toggle" class="toggle-btn" toggle-target="#sidebar">目录 <span class="iconfont"></span></span>

	<a href="http://vip.biancheng.net/?from=topbar" class="user-info iconfont iconfont-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main" class="clearfix">
	<div id="sidebar" class="toggle-target">
	<div id="contents">
		<dt><span class="iconfont iconfont-list-vertical" aria-hidden="true"></span><a href="../golang/golang_2.html">Go语言</a></dt>
		
			<dd>
				<span class="channel-num">1</span>
				<a href='../golang/intro/intro_2.html'>Go语言简介</a>
			</dd>
		
			<dd>
				<span class="channel-num">2</span>
				<a href='../golang/syntax/syntax_2.html'>Go语言基本语法</a>
			</dd>
		
			<dd>
				<span class="channel-num">3</span>
				<a href='../golang/container/container_2.html'>Go语言容器</a>
			</dd>
		
			<dd>
				<span class="channel-num">4</span>
				<a href='../golang/flow_control/flow_control_2.html'>流程控制</a>
			</dd>
		
			<dd>
				<span class="channel-num">5</span>
				<a href='../golang/func/func_2.html'>Go语言函数</a>
			</dd>
		
			<dd>
				<span class="channel-num">6</span>
				<a href='../golang/struct/struct_2.html'>Go语言结构体</a>
			</dd>
		
			<dd>
				<span class="channel-num">7</span>
				<a href='../golang/interface/interface_2.html'>Go语言接口</a>
			</dd>
		
			<dd>
				<span class="channel-num">8</span>
				<a href='../golang/package/package_2.html'>Go语言包（package）</a>
			</dd>
		
			<dd>
				<span class="channel-num">9</span>
				<a href='../golang/concurrent/concurrent_2.html'>Go语言并发</a>
			</dd>
		<dd class="this"> <span class="channel-num">10</span> <a href="../golang/reflect/reflect_2.html">Go语言反射</a> </dd><dl class="dl-sub"><dd>10.1 <a href="4407_2.html">Go语言反射（reflection）</a></dd><dd>10.2 <a href="5131_2.html">Go语言反射规则浅析</a></dd><dd>10.3 <a href="vip_7358_2.html">反射——性能和灵活性的双刃剑</a><span class="iconfont iconfont-vip2"></span></dd><dd>10.4 <a href="109_2.html">通过反射获取类型信息</a></dd><dd>10.5 <a href="110_2.html">通过反射获取指针指向的元素类型</a></dd><dd>10.6 <a href="111_2.html">通过反射获取结构体的成员类型</a></dd><dd>10.7 <a href="112_2.html">Go语言结构体标签</a></dd><dd>10.8 <a href="113_2.html">通过反射获取值信息</a></dd><dd>10.9 <a href="114_2.html">通过反射访问结构体成员的值</a></dd><dd>10.10 <a href="115_2.html">判断反射值的空和有效性</a></dd><dd>10.11 <a href="116_2.html">通过反射修改变量的值</a></dd><dd>10.12 <a href="117_2.html">通过类型信息创建实例</a></dd><dd>10.13 <a href="118_2.html">通过反射调用函数</a></dd><dd>10.14 <a href="5132_2.html">Go语言inject库：依赖注入</a></dd></dl>
			<dd>
				<span class="channel-num">11</span>
				<a href='../golang/102/102_2.html'>Go语言文件处理</a>
			</dd>
		
			<dd>
				<span class="channel-num">12</span>
				<a href='../golang/build/build_2.html'>Go语言编译与工具</a>
			</dd>
		
	</div>
</div>
	<div id="article-wrap">
		<div id="article">
			<div class="arc-info">
	<span class="position"><span class="iconfont iconfont-home2"></span> <a href="../m_biancheng_default_2.html">首页</a> &gt; <a href="../golang/golang_2.html">Go语言</a> &gt; <a href="../golang/reflect/reflect_2.html">Go语言反射</a></span>
</div>

<div id="ggxc-position-bottom" class="ggxc-box"></div>
			<h1>Go语言inject库：依赖注入</h1>
			<div class="pre-next-page clearfix">&nbsp;</div>
			<div id="ggxc-arctop-pc-1" class="ggxc-box"></div>
			<div id="arc-body">在介绍 inject 之前我们先来简单介绍一下&ldquo;依赖注入&rdquo;和&ldquo;控制反转&rdquo;这两个概念。<br />
<br />
正常情况下，对函数或方法的调用是我们的主动直接行为，在调用某个函数之前我们需要清楚地知道被调函数的名称是什么，参数有哪些类型等等。<br />
<br />
所谓的控制反转就是将这种主动行为变成间接的行为，我们不用直接调用函数或对象，而是借助框架代码进行间接的调用和初始化，这种行为称作&ldquo;控制反转&rdquo;，库和框架能很好的解释控制反转的概念。<br />
<br />
依赖注入是实现控制反转的一种方法，如果说控制反转是一种设计思想，那么依赖注入就是这种思想的一种实现，通过注入参数或实例的方式实现控制反转。如果没有特殊说明，我们可以认为依赖注入和控制反转是一个东西。<br />
<br />
控制反转的价值在于解耦，有了控制反转就不需要将代码写死，可以让控制反转的的框架代码读取配置，动态的构建对象，这一点在 <a href='../java/java_2.html' target='_blank'>Java</a> 的 <a href='../spring/spring_2.html' target='_blank'>Spring</a> 框架中体现的尤为突出。<br />
<h2>
	inject 实践</h2>
inject 是依赖注入的Go语言实现，它能在运行时注入参数，调用方法，是 Martini 框架（Go语言中著名的 Web 框架）的基础核心。<br />
<br />
在介绍具体实现之前，先来想一个问题，如何通过一个字符串类型的函数名来调用函数？Go语言没有 Java 中的 Class.forName 方法可以通过类名直接构造对象，所以这种方法是行不通的，能想到的方法就是使用 map 实现一个字符串到函数的映射，示例代码如下：<br />
<pre class="go">
func fl() {
    println (&quot;fl&quot;)
}
func f2 () {
    println (&quot;f2&quot;)
}
funcs := make(map[string] func ())
funcs [&quot;fl&quot;] = fl
funcs [&quot;f2&quot;] = fl
funcs [&quot;fl&quot;]()
funcs [&quot;f2&quot;]()</pre>
但是这有个缺陷，就是 map 的 Value 类型被写成 func()，不同参数和返回值的类型的函数并不能通用。将 map 的 Value 定义为 interface{} 空接口类型即可以解决该问题，但需要借助类型断言或反射来实现，通过类型断言实现等于又绕回去了，反射是一种可行的办法。<br />
<br />
inject 包借助反射实现函数的注入调用，下面通过一个示例来看一下。<br />
<pre class="go">
package main

import (
    &quot;fmt&quot;
    &quot;github.com/codegangsta/inject&quot;
)

type S1 interface{}
type S2 interface{}

func Format(name string, company S1, level S2, age int) {
    fmt.Printf(&quot;name ＝ %s, company=%s, level=%s, age ＝ %d!\n&quot;, name, company, level, age)
}
func main() {
    //控制实例的创建
    inj := inject.New()
    //实参注入
    inj.Map(&quot;tom&quot;)
    inj.MapTo(&quot;tencent&quot;, (*S1)(nil))
    inj.MapTo(&quot;T4&quot;, (*S2)(nil))
    inj.Map(23)
    //函数反转调用
    inj.Invoke(Format)
}</pre>
运行结果如下：
<p class="info-box">
	name ＝ tom, company=tencent, level=T4, age ＝ 23!</p>
可见 inject 提供了一种注入参数调用函数的通用功能，inject.New() 相当于创建了一个控制实例，由其来实现对函数的注入调用。inject 包不但提供了对函数的注入，还实现了对 struct 类型的注入，示例代码如下所示：<br />
<pre class="go">
package main

import (
    &quot;fmt&quot;
    &quot;github.com/codegangsta/inject&quot;
)

type S1 interface{}
type S2 interface{}
type Staff struct {
    Name    string `inject`
    Company S1     `inject`
    Level   S2     `inject`
    Age     int    `inject`
}

func main() {
    //创建被注入实例
    s := Staff{}
    //控制实例的创建
    inj := inject.New()
    //初始化注入值
    inj.Map(&quot;tom&quot;)
    inj.MapTo(&quot;tencent&quot;, (*S1)(nil))
    inj.MapTo(&quot;T4&quot;, (*S2)(nil))
    inj.Map(23)
    //实现对 struct 注入
    inj.Apply(&amp;s)
    //打印结果
    fmt.Printf(&quot;s ＝ %v\n&quot;, s)
}</pre>
运行结果如下：
<p class="info-box">
	s ＝ {tom tencent T4 23}</p>
可以看到 inject 提供了一种对结构类型的通用注入方法。至此，我们仅仅从宏观层面了解 iniect 能做什么，下面从源码实现角度来分析 inject。<br />
<h2>
	inject 原理分析</h2>
inject 包中只有 2 个文件，一个是 inject.go 文件和一个 inject_test.go 文件，这里我们只需要关注 inject.go 文件即可。<br />
<br />
inject.go 短小精悍，包括注释和空行在内才 157 行代码，代码中定义了 4 个接口，包括一个父接口和三个子接口，如下所示：<br />
<pre class="go">
type Injector interface {
    Applicator
    Invoker
    TypeMapper
    SetParent(Injector)
}

type Applicator interface {
    Apply(interface{}) error
}

type Invoker interface {
    Invoke(interface{}) ([]reflect.Value, error)
}

type TypeMapper interface {
    Map(interface{}) TypeMapper
    MapTo(interface{}, interface{}) TypeMapper
    Get(reflect.Type) reflect.Value
}</pre>
Injector 接口是 Applicator、Invoker、TypeMapper 接口的父接口，所以实现了 Injector 接口的类型，也必然实现了 Applicator、Invoker 和 TypeMapper 接口：<br />
<ul>
	<li>
		Applicator 接口只规定了 Apply 成员，它用于注入 struct。</li>
	<li>
		Invoker 接口只规定了 Invoke 成员，它用于执行被调用者。</li>
	<li>
		TypeMapper 接口规定了三个成员，Map 和 MapTo 都用于注入参数，但它们有不同的用法，Get 用于调用时获取被注入的参数。</li>
</ul>
<br />
另外 Injector 还规定了 SetParent 行为，它用于设置父 Injector，其实它相当于查找继承。也即通过 Get 方法在获取被注入参数时会一直追溯到 parent，这是个递归过程，直到查找到参数或为 nil 终止。<br />
<pre class="go">
type injector struct {
    values map[reflect.Type]reflect.Value
    parent Injector
}

func InterfaceOf(value interface{}) reflect.Type {
    t := reflect.TypeOf(value)

    for t.Kind() == reflect.Ptr {
        t = t.Elem()
    }

    if t.Kind() != reflect.Interface {
        panic(&quot;Called inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)&quot;)
    }

    return t
}

func New() Injector {
    return &amp;injector{
        values: make(map[reflect.Type]reflect.Value),
    }
}</pre>
injector 是 inject 包中唯一定义的 struct，所有的操作都是基于 injector struct 来进行的，它有两个成员 values 和 parent。values 用于保存注入的参数，是一个用 reflect.Type 当键、reflect.Value 为值的 map，理解这点将有助于理解 Map 和 MapTo。<br />
<br />
New 方法用于初始化 injector struct，并返回一个指向 injector struct 的指针，但是这个返回值被 Injector 接口包装了。<br />
<br />
InterfaceOf 方法虽然只有几句实现代码，但它是 Injector 的核心。InterfaceOf 方法的参数必须是一个接口类型的指针，如果不是则引发 panic。InterfaceOf 方法的返回类型是 reflect.Type，大家应该还记得 injector 的成员 values 就是一个 reflect.Type 类型当键的 map。这个方法的作用其实只是获取参数的类型，而不关心它的值。<br />
<br />
示例代码如下所示：
<pre class="go">
package main

import (
    &quot;fmt&quot;
    &quot;github.com/codegangsta/inject&quot;
)

type SpecialString interface{}

func main() {
    fmt.Println(inject.InterfaceOf((*interface{})(nil)))
    fmt.Println(inject.InterfaceOf((*SpecialString)(nil)))
}</pre>
运行结果如下：
<p class="info-box">
	interface {}<br />
	main.SpecialString</p>
InterfaceOf 方法就是用来得到参数类型，而不关心它具体存储的是什么值。<br />
<pre class="go">
func (i *injector) Map(val interface{}) TypeMapper {
    i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)
    return i
}

func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {
    i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)
    return i
}

func (i *injector) Get(t reflect.Type) reflect.Value {
    val := i.values[t]
    if !val.IsValid() &amp;&amp; i.parent != nil {
        val = i.parent.Get(t)
    }
    return val
}

func (i *injector) SetParent(parent Injector) {
    i.parent = parent
}</pre>
Map 和 MapTo 方法都用于注入参数，保存于 injector 的成员 values 中。这两个方法的功能完全相同，唯一的区别就是 Map 方法用参数值本身的类型当键，而 MapTo 方法有一个额外的参数可以指定特定的类型当键。但是 MapTo 方法的第二个参数 ifacePtr 必须是接口指针类型，因为最终 ifacePtr 会作为 InterfaceOf 方法的参数。<br />
<br />
为什么需要有 MapTo 方法？因为注入的参数是存储在一个以类型为键的 map 中，可想而知，当一个函数中有一个以上的参数的类型是一样时，后执行 Map 进行注入的参数将会覆盖前一个通过 Map 注入的参数。<br />
<br />
SetParent 方法用于给某个 Injector 指定父 Injector。Get 方法通过 reflect.Type 从 injector 的 values 成员中取出对应的值，它可能会检查是否设置了 parent，直到找到或返回无效的值，最后 Get 方法的返回值会经过 IsValid 方法的校验。<br />
<br />
示例代码如下所示：<br />
<pre class="go">
package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;github.com/codegangsta/inject&quot;
)

type SpecialString interface{}

func main() {
    inj := inject.New()
    inj.Map(&quot;C语言中文网&quot;)
    inj.MapTo(&quot;Golang&quot;, (*SpecialString)(nil))
    inj.Map(20)
    fmt.Println(&quot;字符串是否有效？&quot;, inj.Get(reflect.TypeOf(&quot;Go语言入门教程&quot;)).IsValid())
    fmt.Println(&quot;特殊字符串是否有效？&quot;, inj.Get(inject.InterfaceOf((*SpecialString)(nil))).IsValid())
    fmt.Println(&quot;int 是否有效？&quot;, inj.Get(reflect.TypeOf(18)).IsValid())
    fmt.Println(&quot;[]byte 是否有效？&quot;, inj.Get(reflect.TypeOf([]byte(&quot;Golang&quot;))).IsValid())
    inj2 := inject.New()
    inj2.Map([]byte(&quot;test&quot;))
    inj.SetParent(inj2)
    fmt.Println(&quot;[]byte 是否有效？&quot;, inj.Get(reflect.TypeOf([]byte(&quot;Golang&quot;))).IsValid())
}</pre>
运行结果如下所示：<br />
<p class="info-box">
	字符串是否有效？ true<br />
	特殊字符串是否有效？ true<br />
	int 是否有效？ true<br />
	[]byte 是否有效？ false<br />
	[]byte 是否有效？ true</p>
通过以上例子应该知道 SetParent 是什么样的行为，是不是很像面向对象中的查找链？<br />
<pre class="go">
func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {
    t := reflect.TypeOf(f)

    var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func
    for i := 0; i &lt; t.NumIn(); i++ {
        argType := t.In(i)
        val := inj.Get(argType)
        if !val.IsValid() {
            return nil, fmt.Errorf(&quot;Value not found for type %v&quot;, argType)
        }
        in[i] = val
    }
    return reflect.ValueOf(f).Call(in), nil
}</pre>
Invoke 方法用于动态执行函数，当然执行前可以通过 Map 或 MapTo 来注入参数，因为通过 Invoke 执行的函数会取出已注入的参数，然后通过 reflect 包中的 Call 方法来调用。Invoke 接收的参数 f 是一个接口类型，但是 f 的底层类型必须为 func，否则会 panic。<br />
<pre class="go">
package main

import (
    &quot;fmt&quot;
    &quot;github.com/codegangsta/inject&quot;
)

type SpecialString interface{}

func Say(name string, gender SpecialString, age int) {
    fmt.Printf(&quot;My name is %s, gender is %s, age is %d!\n&quot;, name, gender, age)
}

func main() {
    inj := inject.New()
    inj.Map(&quot;张三&quot;)
    inj.MapTo(&quot;男&quot;, (*SpecialString)(nil))
    inj2 := inject.New()
    inj2.Map(25)
    inj.SetParent(inj2)
    inj.Invoke(Say)
}</pre>
运行结果如下：
<p class="info-box">
	My name is 张三, gender is 男, age is 25!</p>
上面的例子如果没有定义 SpecialString 接口作为 gender 参数的类型，而把 name 和 gender 都定义为 string 类型，那么 gender 会覆盖 name 的值。<br />
<pre class="go">
func (inj *injector) Apply(val interface{}) error {
    v := reflect.ValueOf(val)

    for v.Kind() == reflect.Ptr {
        v = v.Elem()
    }

    if v.Kind() != reflect.Struct {
        return nil
    }

    t := v.Type()

    for i := 0; i &lt; v.NumField(); i++ {
        f := v.Field(i)
        structField := t.Field(i)
        if f.CanSet() &amp;&amp; structField.Tag == &quot;inject&quot; {
            ft := f.Type()
            v := inj.Get(ft)
            if !v.IsValid() {
                return fmt.Errorf(&quot;Value not found for type %v&quot;, ft)
            }
            f.Set(v)
        }
    }
    return nil
}</pre>
Apply 方法是用于对 struct 的字段进行注入，参数为指向底层类型为结构体的指针。可注入的前提是：字段必须是导出的（也即字段名以大写字母开头），并且此字段的 tag 设置为<code style="font-size: 14px;">`inject`</code>。<br />
<br />
示例代码如下所示：<br />
<pre class="go">
package main

import (
    &quot;fmt&quot;
    &quot;github.com/codegangsta/inject&quot;
)

type SpecialString interface{}

type TestStruct struct {
    Name   string `inject`
    Nick   []byte
    Gender SpecialString `inject`
    uid    int           `inject`
    Age    int           `inject`
}

func main() {
    s := TestStruct{}
    inj := inject.New()
    inj.Map(&quot;张三&quot;)
    inj.MapTo(&quot;男&quot;, (*SpecialString)(nil))
    inj2 := inject.New()
    inj2.Map(26)
    inj.SetParent(inj2)
    inj.Apply(&amp;s)
    fmt.Println(&quot;s.Name =&quot;, s.Name)
    fmt.Println(&quot;s.Gender =&quot;, s.Gender)
    fmt.Println(&quot;s.Age =&quot;, s.Age)
}</pre>
运行结果如下：
<p class="info-box">
	s.Name = 张三<br />
	s.Gender = 男<br />
	s.Age = 26</p>
</div>
			<div id="ggxc-weixin-arcbottom">
	<p>关注公众号「<span class="col-green">站长严长生</span>」，在手机上阅读所有教程，随时随地都能学习。内含一款搜索神器，免费下载全网书籍和视频。</p>
	<p style="margin-top:12px; text-align:center;">
		<img src="../templets/new/images/material/qrcode_mp_4.png" alt="公众号二维码" width="160" /><br />
		<span class="col-green">微信扫码关注公众号</span>
	</p>
</div>
			<div class="pre-next-page clearfix">&nbsp;</div>
			<div id="nice-arcs" class="box-bottom">
    <h4>推荐阅读</h4>
    <ul class="clearfix">
<li><a href="niz69i_8.html" title="一套完整的嵌入式开发学习路线（高薪就业版）" target="_blank">一套完整的嵌入式开发学习路线（高薪就业版）</a></li>
<li><a href="tnnfqo_4.html" title="一套课程卖1万，TMD太贵了！" target="_blank">一套课程卖1万，TMD太贵了！</a></li>
<li><a href="unnurw_4.html" title="跑了3000公里，见了一位大佬" target="_blank">跑了3000公里，见了一位大佬</a></li>
<li><a href="540_2.html" title="C语言分块查找算法，索引顺序查找算法" target="_blank">C语言分块查找算法，索引顺序查找算法</a></li>
<li><a href="2259_2.html" title="Python变量作用域（全局变量和局部变量）" target="_blank">Python变量作用域（全局变量和局部变量）</a></li>
<li><a href="4593_2.html" title="什么是异常处理，Python常见异常类型（入门必读）" target="_blank">什么是异常处理，Python常见异常类型（入门必读）</a></li>
<li><a href="7230_2.html" title="C++ STL无序容器（哈希容器）是什么？" target="_blank">C++ STL无序容器（哈希容器）是什么？</a></li>
<li><a href="../css3/pseudo-element_2.html" title="CSS伪元素（非常详细）" target="_blank">CSS伪元素（非常详细）</a></li>
<li><a href="../css3/responsive_2.html" title="CSS响应式布局（自适应布局）教程" target="_blank">CSS响应式布局（自适应布局）教程</a></li>
<li><a href="../c/cosh_2.html" title="C语言cosh()：求双曲余弦" target="_blank">C语言cosh()：求双曲余弦</a></li>
</ul>
</div>
		</div>
		
	</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 5132;
window.arcId = "1064EpVnAzFtwH+Q13alB4ACAA91iffJISSrqWbkdQgGyU/E2N9AB88S8NM";
window.typeidChain = "13|1";
</script>
<div id="footer" class="clearfix">
	<div class="info left">
	<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
	<p>
		<a href="8066_2.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
		<a href="8092_3.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
		<a href="8097_2.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
		<a href="9648_2.html" target="_blank" rel="nofollow">公众号</a> <span>|</span>
		<a href="8093_2.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
		<a href="../sitemap/sitemap_2.html" target="_blank" rel="nofollow">网站地图</a>
	</p>
	<p>Copyright ©2012-2022 biancheng.net, <a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow" style="color:#666;">冀ICP备2022013920号</a>, <img height="13" src="../templets/new/images/gongan_2.png" alt="公安备案图标" /><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13110202001352" target="_blank" rel="nofollow" style="color:#666;">冀公网安备13110202001352号</a>
	</p>
	</div>
	<img id="logo_bottom" class="right" src="https://m.biancheng.net/templets/new/images/logo_bottom_2.gif" alt="底部Logo" />
	<span id="return-top"><b>↑</b></span>
</div>

<div id="addweixin-widget">
	<p>
		<script type="text/javascript">
			/*var suffix = 'c';
			var thisMin = (new Date()).getMinutes();
			if(thisMin>=40){
				suffix = 'd';
			}else if(thisMin>=20){
				suffix = 'e';
			}else{
				suffix = 'c';
			}
			document.write('<img src="https://m.biancheng.net/templets/new/images/material/qrcode_wx_'%20+%20suffix%20+'.png?v=1.7.07" alt="微信交流群" width="120" /><br />');*/
		</script>
		<img src="https://m.biancheng.net/templets/new/images/material/qrcode_mp_4.png" alt="微信交流群" width="120" />
		<span>关注微信公众号，加入官方交流群。内含一款搜索神器，免费下载全网书籍和视频。</span>
	</p>
	<span id="close-addweixin-widget" class="iconfont iconfont-close"></span>
</div>

<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.7.07";
window.prePageURL = "/view/118.html";
window.nextPageURL = "/golang/102/";
</script>

<script src="https://m.biancheng.net/templets/new/script/jquery1.12.4.min_2.js"></script>
<script src="https://m.biancheng.net/templets/new/script/common_2.js"></script>
<!-- 51la V6 -->
<span style="display: none;">
<script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"KDf6QzBhogyQjall",ck:"KDf6QzBhogyQjall",autoTrack:true})</script>
</span>
<!-- 51la V5 -->
<!-- <span style="display: none;"><script type="text/javascript" src="https://js.users.51.la/21368967.js"></script></span> -->
</body>
</html>