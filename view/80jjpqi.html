<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="renderer" content="webkit" />
<meta name="force-rendering" content="webkit"/>
<meta name="applicable-device" content="pc,mobile" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="format-detection" content="telephone=no" />
<link rel="shortcut icon" href="../favicon.ico" />
<link href="../templets/new/style/common.css" rel="stylesheet" />
<title>Webpack入门教程（简明版）</title>
<meta name="description" content="本文会对 Webpack 进行大致介绍，让大家对 Webpack 有一个初步的了解，主要内容如下： 何为Webpack； 使用Webpack的意义； 安装Webpack； 如何开始一个Webpack工程。 如果你已经是一个Webpack老手" />
</head>
<body>
<div id="topbar" class="clearfix">
<ul id="product-type" class="left">
<li>
<a href="../c_biancheng_default.html"><span class="iconfont iconfont-home"></span>首页</a>
</li>
<li class="active">
<a href="../sitemap/sitemap_3.html" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
</li>
<li>
<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
</li>
<li>
<a href="../fudao_biancheng_default.html" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
</li>
<li>
<a href="niz69i.html" target="_blank"><span class="iconfont iconfont-chip"></span>嵌入式学习路线</a>
</li>
</ul>
</div>
<div id="header" class="clearfix">
<a id="logo" class="left" href="../c_biancheng_default.html">
<img height="26" src="../templets/new/images/logo.png" alt="C语言中文网" />
</a>
<ul id="nav-main" class="hover-none left clearfix">
<li class="wap-yes"><a href="../c_biancheng_default.html">首页</a></li>
<li><a href="../c/c_3.html">C语言教程</a></li>
<li><a href="../cplus/cplus.html">C++教程</a></li>
<li><a href="../python/python.html">Python教程</a></li>
<li><a href="../java/java_3.html">Java教程</a></li>
<li><a href="../linux_tutorial/linux_tutorial.html">Linux入门</a></li>
<li><a href="../sitemap/sitemap_3.html" title="网站地图">更多&gt;&gt;</a></li>
</ul>
<a href="http://vip.biancheng.net/?from=topbar" class="user-info iconfont iconfont-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main-no-course" class="clearfix">
<div class="arc-info">
<span class="position"><span class="iconfont iconfont-home2"></span> <a href="../c_biancheng_default.html">首页</a> &gt; 编程笔记</span>
</div>
<div id="ggxc-position-bottom" class="ggxc-box"></div>
<h1>Webpack入门教程（简明版）</h1>
<div id="ggxc-arctop-pc-1" class="ggxc-box"></div>
<div id="arc-body">本教程会对 Webpack 进行大致介绍，让大家对 Webpack 有一个初步的了解，主要内容如下：
<ul>
<li>
Webpack 是什么</li>
<li>
使用 Webpack 的意义；</li>
<li>
安装 Webpack；</li>
<li>
如何开始一个 Webpack 工程。</li>
</ul>
<br />
如果你已经是一个 Webpack 老手，可以跳过了；假如你对 Webpack 还不是很熟悉，那么本教程会带你快速上手。
<h2 class="center">
1. Webpack 是什么？</h2>
Webpack 是一个开源的 JavaScript 模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个 JS 文件，这个过程就叫作模块打包。
<p class="tip-box">
有时会合并为多个 JS 文件，这里讨论的只是最基本的情况。</p>
你可以把 Webpack 理解为一个模块处理工厂。我们把源代码交给 Webpack，由它去进行加工、拼装处理，产出最终的资源文件，等待送往用户。<br />
<br />
没有接触过打包工具的读者可能会疑惑，在 Web 开发中与我们打交道的无非是 HTML、CSS、JS 等静态资源，为什么不直接将工程中的源文件发布到服务器或 CDN，而要交给 Webpack 处理呢？这两者之间有什么不同？<br />
<br />
接下来我们就来阐述使用 Webpack 的意义。
<h2 class="center">
2. 为什么需要Webpack？</h2>
开发一个简单的 Web 应用，其实只需要浏览器和一个简单的编辑器就可以了。最早的 Web 应用就是这么开发的，因为需求很简单。<br />
<br />
但是，当应用的规模大了之后，就必须借助一定的工具，否则人工维护代码的成本将逐渐变得难以承受。使用工具可以让开发效率成倍地提升，所谓&ldquo;工欲善其事，必先利其器&rdquo;就是这个意思。<br />
<br />
说回 Webpack，既然它解决的最主要问题是模块打包，那么为了更好地阐述 Webpack 的作用，我们必须先谈谈模块。
<h3>
1) 模块是什么？</h3>
我们每时每刻都在与模块打交道，比如，在工程中引入一个日期处理的 npm 包，或者编写一个提供工具方法的 JS 文件，这些包和文件都可以称为模块。<br />
<br />
在设计程序结构时，把所有代码都堆到一起是非常糟糕的做法。更好的组织方式是按照特定的功能将其拆分为多个代码段，每个代码段实现一个特定的目的。你可以对其进行独立的设计、开发和测试，最终通过接口来将它们组合在一起。这就是基本的模块化思想。<br />
<br />
如果把程序比作一个城市，这个城市内部有不同的职能部门，如学校、医院、消防局等。程序中的模块就像这些职能部门一样，每一个都有其特定的功能。各个模块协同工作，才能保证程序的正常运转。
<h3>
2) JavaScript中的模块</h3>
在大多数程序语言（如 C、C++、Java）中，开发者都可以直接使用模块进行开发。工程中的各个模块在经过编译、链接等过程后会被整合成单一的可执行文件并交由系统运行。<br />
<br />
对于 JavaScript 来说，情况则有所不同。在过去的很长一段时间里，JavaScript 这门语言并没有模块这一概念。如果工程中有多个 JS 文件，我们只能通过 script 标签将它们一个个插入页面中。<br />
<br />
为何偏偏 JavaScript 没有模块呢？<br />
<br />
如果要追溯历史原因，JavaScript 之父 Brendan Eich 最初设计这门语言时只是将它定位成一个小型的脚本语言，用来实现网页上一些简单的动态特性，远没有考虑到会用它实现今天这样复杂的场景，模块化当然也就显得多余了。<br />
<br />
随着技术的发展，JavaScript 已经不仅仅用来实现简单的表单提交等功能，引入多个 script 文件到页面中逐渐成为一种常态，但我们发现这种做法有很多缺点，比如：
<ul>
<li>
需要手动维护 JavaScript 的加载顺序。页面的多个 script 之间通常会有依赖关系，但由于这种依赖关系是隐式的，除了添加注释以外很难清晰地指明谁依赖了谁，所以当页面中加载的文件过多时很容易出现问题。</li>
<li>
每一个 script 标签都意味着需要向服务器请求一次静态资源，在 HTTP 2 还没有出现的时期，建立连接的成本是很高的，过多的请求会严重拖慢网页的渲染速度。</li>
<li>
在每个 script 标签中，顶层作用域即全局作用域，没有任何处理而直接在代码中进行变量或函数声明会污染全局作用域。</li>
</ul>
<br />
模块化则解决了上述所有问题：
<ul>
<li>
通过导入和导出语句我们可以清晰地看到模块间的依赖关系。</li>
<li>
模块可以借助工具来进行打包，所以在页面中只需要加载合并后的资源文件，减少了网络开销。</li>
<li>
多个模块之间的作用域是隔离的，彼此不会有命名冲突。</li>
</ul>
<br />
从 2009 年开始，JavaScript 社区开始对模块化进行不断的尝试，并先后给出了 AMD、CommonJS、CMD 等解决方案。但这些都只是由社区提出的，并不能算作语言本身的特性。而在 2015 年，ECMAScript 6.0（ES6）正式定义了 JavaScript 模块标准，使这门语言在诞生了 20 年之后终于拥有了模块这一概念。<br />
<br />
ES6 模块标准目前已经得到了大多数现代浏览器的支持，但在实际应用方面还需要等待一段时间，主要有以下几点原因：
<ul>
<li>
无法使用代码分片（code splitting）和删除死代码（tree shaking）（Webpack 的两个特别重要的特性）。</li>
<li>
大多数 npm 模块还是 CommonJS 的形式，而浏览器并不支持其语法，因此这些包没有办法直接拿来用。</li>
<li>
仍然需要考虑个别浏览器及平台的兼容性问题。</li>
</ul>
<br />
那么，如何才能让我们的工程在使用模块化的同时也能正常运行在浏览器中呢？这就到了模块打包工具出场的时候了。
<h3>
3) 模块打包工具</h3>
模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。<br />
<br />
模块打包工具的工作方式主要分为两种：
<ul>
<li>
将存在依赖关系的模块按照特定规则合并为单个 JS 文件，一次全部加载进页面中。</li>
<li>
在页面初始时加载一个入口模块，异步加载其他模块。</li>
</ul>
<br />
目前社区中比较流行的模块打包工具有 Webpack、Vite、Parcel、Rollup 等。
<h3>
4) 为什么选择 Webpack？</h3>
对比同类模块打包工具，Webpack 具备以下几点优势。
<h4>
① Webpack 默认支持多种模块标准</h4>
Webpack 可以支持包括 AMD、CommonJS 以及最新的 ES6 模块，而其他工具大多只能支持一到两种。Webpack 对于一些同时使用多种模块标准的工程非常有用，它会帮我们处理好不同类型模块之间的依赖关系。
<h4>
② Webpack 有完备的代码分片解决方案</h4>
从字面意思去理解，它可以分割打包后的资源，在首屏只加载必要的部分，将不太重要的功能放到后面动态加载。这对于资源体积较大的应用来说尤为重要，可以有效地减小资源体积，提升首页渲染速度。
<h4>
③ Webpack 可以处理各种类型的资源</h4>
除了 JavaScript 以外，Webpack 还可以处理样式、模板，甚至图片等，而开发者需要做的仅仅是导入它们。比如你可以从 JavaScript 文件导入一个 CSS 或者 PNG，而这一切最终都可以由 Webpack 的 loader 来处理。
<h4>
④ Webpack 拥有庞大的社区支持</h4>
除了 Webpack 核心库以外，还有无数开发者来为它编写周边插件和工具。对于绝大多数的需求，你都可以直接在社区找到已有解决方案，甚至会找到多个解决方案。<br />
<br />
以上我们对 Webpack 进行了简要介绍，但是说再多也不如实际操作一次，现在上手试一试吧。
<h2 class="center">
3. Webpack 安装</h2>
Webpack 对于操作系统没有要求，使用 Windows、Mac、Linux 操作系统均可。它唯一的依赖就是 Node.js，下面来进行安装。<br />
<br />
Webpack 对 Node.js 的版本是有一定要求的，推荐使用 Node.js 的 LTS（Long Term Support，长期维护）版本。<br />
<br />
LTS 版本是 Node.js 在&ldquo;当前阶段&rdquo;较为稳定的版本，具体版本号及发布计划可以到 <a href="https://github.com/nodejs/Release" target="_blank">https://github.com/nodejs/Release</a> 自行查看。LTS 版本中不会包含过于激进的特性，并且已经经过了一定时间的检验，比较适合生产环境。大多数 Node.js 模块也都会依照 LTS 版本的特性提供支持。<br />
<br />
Node.js 官网（<a href="https://nodejs.org/" target="_blank">https://nodejs.org/</a>）一般都会把 LTS 版本放在较为醒目的位置，用户根据自己的系统环境进行下载和安装即可。安装完成后，打开命令行并执行 node-v，不出意外的话会显示当前 Node.js 的版本号，代表已经安装成功。<br />
<br />
接下来，我们需要使用 Node.js 的包管理器 npm 来安装 Webpack。使用过 npm 的读者应该知道，安装模块的方式有两种：一种是全局安装，一种是本地安装。<br />
<br />
对于 Webpack 来说，我们也有这两种选择：
<ul>
<li>
全局安装 Webpack 的好处是 npm 会帮我们绑定一个命令行环境变量，一次安装、处处运行；</li>
<li>
本地安装 Webpack 则会添加其为项目中的依赖，只能在项目内部使用。</li>
</ul>
<br />
这里建议使用本地安装的方式，主要有以下两点原因：
<ul>
<li>
如果选择全局安装，那么在与他人进行项目协作的时候，由于每个人系统中的 Webpack 版本不同，可能会导致输出结果不一致。</li>
<li>
部分依赖于 Webpack 的插件会调用项目中 Webpack 的内部模块，这种情况下仍然需要在项目本地安装 Webpack，而如果全局和本地都有，则容易造成混淆。</li>
</ul>
<br />
基于以上两点，我们选择在工程内部安装 Webpack。<br />
<br />
首先新建一个工程目录，从命令行进入该目录，并执行 npm 的初始化命令。
<pre class="info-box">
npm init # 如果你使用 yarn，则为 yarn init</pre>
此时会要求你输入项目的基本信息，因为这里只是为了生成一个示例，根据提示操作就好。<br />
<br />
然后，我们会看到目录中生成了一个 package.json 文件，它相当于 npm 项目的说明书，里面记录了项目名称、版本、仓库地址等信息。<br />
<br />
接下来执行安装 Webpack 的命令：
<pre class="info-box">
npm install webpack webpack-cli -D
# or yarn
yarn add webpack webpack-cli &ndash;D</pre>
这里我们同时安装了 webpack 以及 webpack-cli。webpack 是核心模块，webpack-cli 则是命令行工具，在本例中两者都是必需的。<br />
<br />
安装结束之后，在命令行执行 npx webpack -v 以及 npx webpack-cli -v，可显示版本号即证明安装成功。
<p class="tip-box">
注意：由于我们将 Webpack 安装在了本地，因此无法直接在命令行内使用 webpack 指令，工程内部只能使用 npx webpack &lt;command&gt; 的形式。</p>
<h2 class="center">
4. 打包第一个应用</h2>
现在让我们趁热打铁来打包刚刚的示例工程。如果你是第一次接触 Webpack，建议按照下面的指引一步步进行操作。代码中不熟悉的地方也不必深究，这个示例只是为了让我们直观地认识 Webpack 的一些特性。
<h3>
1) Hello World</h3>
首先，我们在工程目录下添加以下几个文件。
<h4>
① index.js 文件</h4>
<pre class="javascript">
import addContent from &#39;./add-content.js&#39;;
document.write(&#39;My first Webpack app.&lt;br /&gt;&#39;);
addContent();
add-content.js：

export default function() {
    document.write(&#39;Hello world!&#39;);
}</pre>
<h4>
② add-content.js 文件</h4>
<pre class="javascript">
export default function() {
    document.write(&#39;Hello world!&#39;);
}</pre>
<h4>
③ index.html 文件</h4>
<pre class="html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;My first Webpack app.&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
然后在控制台输入打包命令：
<pre class="info-box">
npx webpack --entry=./index.js --mode=development</pre>
用浏览器打开 index.html，这时应该可以看到在页面上会显示&ldquo;My first Webpack app. Hello world!&rdquo;，如图1所示。<br />
<br />
<div style="text-align: center;">
<img alt="index.html 输出结果" src="../uploads/allimg/230717/1-230GG050523V.png" /><br />
图1：index.html 输出结果</div>
<br />
Webpack 帮我们完成了一项最基本的模块组装工作，现在回顾一下刚刚输入的指令。<br />
<br />
命令行的第1个参数 entry 是资源打包的入口。Webpack 从这里开始进行模块依赖的查找，找到 index.js 和 add-content.js 两个模块，并通过它们来生成最终产物。<br />
<br />
命令行的第2个参数 output-filename 是输出资源名。你会发现打包完成后工程中出现了一个 dist 目录，其中包含的 main.js 就是 Webpack 的打包结果。<br />
<br />
最后的参数 mode 指的是打包模式。Webpack 为开发者提供了 development、production、none 三种模式。<br />
<br />
当置于 development 和 production 模式下时，它会自动添加适合当前模式的一系列配置，减少了人为的工作量。在开发环境下，一般设置为 development 模式就可以了。<br />
<br />
为了验证打包结果，可以用浏览器打开 index.html。项目中的 index.js 和 content.js 现在已经成为 bundle.js，被页面加载和执行，并输出了各自的内容。
<h3>
2) 使用 npm scripts</h3>
从上面的例子不难发现，我们每进行一次打包都要输入一段冗长的命令，这样做不仅耗时，而且容易出错。为了使命令行指令更简洁，可以在 package.json 中添加一个脚本命令。<br />
<br />
编辑工程中的 package.json 文件：
<pre class="info-box">
&hellip;&hellip;
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;webpack --entry=./index.js --mode=development&quot;
    },
&hellip;&hellip;</pre>
scripts 是 npm 提供的脚本命令功能，在这里我们可以直接使用由模块添加的指令（比如用 webpack 取代之前的 npx webpack）。<br />
<br />
为了验证打包结果，可以对 add-content.js 的内容稍加修改：
<pre class="info-box">
export default function() {
    document.write(&#39;I\&#39;m using npm scripts!&#39;);
}</pre>
重新打包，这次输入 npm 命令即可：
<pre class="info-box">
npm run build</pre>
打开浏览器验证效果，如图2所示。<br />
<br />
<div style="text-align: center;">
<img alt="index.html内容变为“I'm using npm scripts!”" src="../uploads/allimg/230717/1-230GG052015I.png" /><br />
图2：index.html内容变为&ldquo;I&#39;m using npm scripts!&rdquo;</div>
<h3>
3) 使用默认目录配置</h3>
上面的 index.js 是放在工程根目录下的，而通常情况下我们会分别设置源码目录与资源输出目录。比如，工程源代码放在 /src 中，输出资源放在 /dist 中。<br />
<br />
在工程中创建一个 src 目录，并将 index.js 和 add-content.js 移动到该目录下。对于资源输出目录来说，Webpack 已经默认是 /dist，我们不需要做任何改动。<br />
<br />
另外需要提到的是，Webpack 默认的源代码入口就是 src/index.js，因此现在可以省略 entry 的配置了。<br />
<br />
编辑package.json：
<pre class="info-box">
&hellip;&hellip;
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;webpack --output-filename=bundle.js --mode=development&quot;
    },
&hellip;&hellip;</pre>
虽然目录命名并不是强制的，且 Webpack 提供了配置项让我们进行更改，但还是建议遵循统一的命名规范，这样会使得大体结构比较清晰，也利于多人协作。
<h3>
4) 使用配置文件</h3>
为了满足不同应用场景的需求，Webpack 拥有非常多的配置项以及相对应的命令行参数。<br />
<br />
我们可以通过 Webpack 的帮助命令来进行查看：
<pre class="info-box">
npx webpack &ndash;h</pre>
部分参数如图3所示。<br />
<br />
<div style="text-align: center;">
<img alt="Webpack 配置参数" src="../uploads/allimg/230717/1-230GG05310153.png" /><br />
图3：Webpack 配置参数</div>
<br />
从之前我们在 package.json 中添加的脚本命令来看，当项目需要越来越多的配置时，就要往命令中添加更多的参数，那么到后期维护起来就会相当困难。为了解决这个问题，可以把这些参数改为对象的形式专门放在一个配置文件里，在 Webpack 每次打包的时候读取该配置文件即可。<br />
<br />
Webpack 的默认配置文件为 webpack.config.js（也可以使用其他文件名，需要使用命令行参数指定）。现在让我们在工程根目录下创建 webpack.config.js，并添加如下代码：
<pre class="info-box">
module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        filename: &#39;main.js&#39;,
    },
    mode: &#39;development&#39;,
}</pre>
上面通过 module.exports 导出了一个对象，也就是打包时被 Webpack 接收的配置对象。先前在命令行中输入的一大串参数就都要改为 key-value 的形式放在这个对象中。<br />
<br />
目前该对象包含两个关于资源输入输出的属性&mdash;&mdash;entry 和 output。entry 就是我们的资源入口，output 则是一个包含更多详细配置的对象。<br />
<br />
在 Webpack 配置中，我们经常会遇到这种层叠的属性关系。这是由于 Webpack 本身的配置实在太多，如果都放在同一级会难以管理，因此出现了这种多级配置。当开发者要修改某个配置项时，通过层级关系找下来会更加清晰、快捷。<br />
<br />
之前的参数 --output-filename 和 --output-path 现在都成为 output 下面的属性。filename 和先前一样都是 bundle.js，不需要改动，而 path 和之前有所区别。<br />
<br />
Webpack 对于 output.path 的要求是使用绝对路径（从系统根目录开始的完整路径），之前我们在命令行中为了简洁而使用了相对路径。而在 webpack.config.js 中，我们通过调用 Node.js 的路径拼装函数 path.join，将 __dirname（Node.js 内置全局变量，值为当前文件所在的绝对路径）与 dist（输出目录）连接起来，得到了最终的资源输出路径。<br />
<br />
现在我们可以去掉 package.json 中配置的打包参数了：
<pre class="info-box">
&hellip;&hellip;
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;webpack&quot;
    },
&hellip;&hellip;</pre>
为了验证最终效果，我们再对 add-content.js 的内容稍加修改：
<pre class="info-box">
export default function() {
    document.write(&#39;I\&#39;m using a config file!&#39;);
}</pre>
执行 npm run build 命令，Webpack 就会预先读取 webpack.config.js，然后打包。完成之后我们打开 index.html 进行验证，结果如图4所示。<br />
<br />
<div style="text-align: center;">
<img alt="index.html内容变为“I'm using a config file!”" src="../uploads/allimg/230717/1-230GG054241A.png" /><br />
图4：index.html内容变为&ldquo;I&#39;m using a config file!&rdquo;</div>
<h3>
5) webpack-dev-server</h3>
到这里，其实我们已经把 Webpack 的初始环境配置好了。<br />
<br />
你可能会发现，单纯使用 Webpack 以及它的命令行工具来进行开发调试的效率并不高。以往只要编辑项目源文件（JS、CSS、HTML 等），刷新页面即可看到效果，现在多了一步打包，即我们在改完项目源码后要执行 npm run build 更新 bundle.js，然后才能刷新页面生效。有没有更简便的方法呢？<br />
<br />
其实 Webpack 社区已经为我们提供了一个便捷的本地开发工具&mdash;&mdash;webpack-dev-server。<br />
<br />
用以下命令进行安装：
<pre class="info-box">
npm install webpack-dev-server -D</pre>
安装指令中的<code>-D</code>参数是将 webpack-dev-server 作为工程的 devDependencies（开发环境依赖）记录在 package.json中。这样做是因为 webpack-dev-server 仅仅在本地开发时才会用到，在生产环境中并不需要它，所以放在 devDependencies 中是比较恰当的。<br />
<br />
假如工程上线时要进行依赖安装，就可以通过 npm install --only=prod 过滤掉 devDependencies 中的冗余模块，从而加快安装和发布的速度。<br />
<br />
为了便捷地启动 webpack-dev-server，我们在 package.json 中添加一个 dev 指令：
<pre class="info-box">
&hellip;&hellip;
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;webpack&quot;,
        &quot;dev&quot;: &quot;webpack-dev-server&quot;
    },
&hellip;&hellip;</pre>
最后，我们还需要对 webpack-dev-server 进行配置。编辑 webpack.config.js：
<pre class="info-box">
module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        filename: &#39;./main.js&#39;,
    },
    mode: &#39;develpoment&#39;,
    devServer: {
        publicPath: &#39;/dist&#39;,
    },
};</pre>
可以看到，我们在配置中添加了一个 devServer 对象，它是专门用来放 webpack-dev-server 配置的。<br />
<br />
webpack-dev-server 可以看作一个服务者，它的主要工作就是接收浏览器的请求，然后将资源返回。<br />
<br />
当服务启动时，它会先让 Webpack 进行模块打包并将资源准备好（在示例中就是 bundle.js）。当webpack-dev-server 接收到浏览器的资源请求时，它会首先进行 URL 地址校验：
<ul>
<li>
如果该地址是资源服务地址（上面配置的 publicPath），webpack-dev-server 就会从 Webpack 的打包结果中寻找该资源并返回给浏览器。</li>
<li>
反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。</li>
</ul>
<br />
综上我们可以总结出 webpack-dev-server 的两大职能：
<ul>
<li>
令Webpack进行模块打包，并处理打包结果的资源请求。</li>
<li>
作为普通的Web Server，处理静态资源文件请求。</li>
</ul>
<br />
最后，在启动服务之前，我们还是更改一下 add-content.js：
<pre class="info-box">
export default function() {
    document.write(&#39;I\&#39;m using webpack-dev-server!&#39;);
}</pre>
一切就绪，执行 npm run dev 命令并用浏览器打开 http://localhost:8080/，可以看到如图5所示的输出结果。<br />
<br />
<div style="text-align: center;">
<img alt="index.html内容变为“I'm using webpack-dev-server!”" src="../uploads/allimg/230717/1-230GG05516348.png" /><br />
图5：index.html内容变为&ldquo;I&#39;m using webpack-dev-server!&rdquo;</div>
<br />
这里有一点需要注意。直接用 Webpack 开发和使用 webpack-dev-server 有一个很大的区别，前者每次都会生成 main.js，而 webpack-dev-server 只是将打包结果放在内存中，并不会写入实际的 bundle.js，在每次 webpack-dev-server 接收到请求时都只是将内存中的打包结果返回给浏览器。<br />
<br />
这一点可以通过删除工程中的 dist 目录来验证，你会发现即便 dist 目录不存在，刷新页面后功能仍然是正常的。从开发者的角度来看，这其实是符合情理的。在本地开发阶段我们经常会调整目录结构和文件名，如果每次都写入实际文件，最后就会产生一些没用的垃圾文件，还会干扰我们的版本控制，因此 webpack-dev-server 的处理方式显得更加简洁。<br />
<br />
webpack-dev-server 还有一项很便捷的特性&mdash;&mdash;live-reloading（自动刷新）。例如我们保持本地服务启动以及浏览器打开的状态，到编辑器中去更改 add-content.js：
<pre class="info-box">
export default function() {
    document.write(&#39;This is from live-reloading!&#39;);
}</pre>
此时切回到浏览器，你会发现浏览器的内容自动更新了，这就是 live-reloading 的功能。当 webpack-dev-server 发现工程源文件进行了更新操作后就会自动刷新浏览器，显示更新后的内容。该特性可以提升本地开发的效率。<br />
<br />
当然，还有更先进的 hot-module-replacement（模块热替换），它甚至不需要刷新浏览器就能获取更新之后的内容。由于篇幅限制，这里不再赘述。
<h2 class="center">
5. 小结</h2>
本教程我们介绍了 Webpack 的功能：它可以处理模块之间的依赖，将它们串联起来合并为单一的 JS 文件。<br />
<br />
在安装 Webpack 时我们一般选择在项目本地安装的方式，这样可以使团队开发时共用一个版本，并且可以让其他插件直接获取 Webpack 的内部模块。<br />
<br />
配置本地开发环境可以借助 npm scripts 来维护命令行脚本，当打包脚本参数过多时，我们需要将其转化为 webpack.config.js，用文件的方式维护复杂的 Webpack 配置。<br />
<br />
webpack-dev-server 的作用是启动一个本地服务，可以处理打包资源与静态文件的请求。它的 live-reloading 功能可以监听文件变化，自动刷新页面来提升开发效率。<br />
</div>
<div id="ggxc-weixin-arcbottom">
<p>关注公众号「<span class="col-green">站长严长生</span>」，在手机上阅读所有教程，随时随地都能学习。内含一款搜索神器，免费下载全网书籍和视频。</p>
<p style="margin-top:12px; text-align:center;">
<img src="../templets/new/images/material/qrcode_mp.png" alt="公众号二维码" width="160" /><br />
<span class="col-green">微信扫码关注公众号</span>
</p>
</div>
<div id="nice-arcs" class="box-bottom">
<h4>推荐阅读</h4>
<ul class="clearfix">
<li><a href="niz69i_4.html" title="一套完整的嵌入式开发学习路线（高薪就业版）" target="_blank">一套完整的嵌入式开发学习路线（高薪就业版）</a></li>
<li><a href="tnnfqo_2.html" title="一套课程卖1万，TMD太贵了！" target="_blank">一套课程卖1万，TMD太贵了！</a></li>
<li><a href="unnurw_2.html" title="跑了3000公里，见了一位大佬" target="_blank">跑了3000公里，见了一位大佬</a></li>
<li><a href="5833.html" title="什么是多态，Python多态及用法详解" target="_blank">什么是多态，Python多态及用法详解</a></li>
<li><a href="vip_5917.html" title="C语言学生信息管理系统源码下载和思路解析（文件版）" target="_blank">C语言学生信息管理系统源码下载和思路解析（文件版）</a></li>
<li><a href="8200.html" title="JS split()分割字符串" target="_blank">JS split()分割字符串</a></li>
<li><a href="vip_8315.html" title="SQL查询语句先执行SELECT？兄弟你认真的么？" target="_blank">SQL查询语句先执行SELECT？兄弟你认真的么？</a></li>
<li><a href="../dll/vip_8706.html" title="Windows下动态链接库的创建和使用" target="_blank">Windows下动态链接库的创建和使用</a></li>
<li><a href="../spring_boot/datasource-cofig.html" title="Spring Boot数据源配置原理" target="_blank">Spring Boot数据源配置原理</a></li>
<li><a href="shell-sort.html" title="希尔排序算法" target="_blank">希尔排序算法</a></li>
</ul>
</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 10079;
window.arcId = "f756yky+IIV1/0LM3WfcNm2vrySihfjcLpgjV0R1/3/2u7BYRCKveRk0Cpns";
window.typeidChain = "213|119";
</script>
<div id="footer" class="clearfix">
<div class="info left">
<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
<p>
<a href="8066.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
<a href="8092_2.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
<a href="8097.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
<a href="9648.html" target="_blank" rel="nofollow">公众号</a> <span>|</span>
<a href="8093.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
<a href="../sitemap/sitemap_3.html" target="_blank" rel="nofollow">网站地图</a>
</p>
<p>Copyright ©2012-2022 biancheng.net, <a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow" style="color:#666;">冀ICP备2022013920号</a>, <img height="13" src="https://c.biancheng.net/templets/new/images/gongan.png" alt="公安备案图标" /><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13110202001352" target="_blank" rel="nofollow" style="color:#666;">冀公网安备13110202001352号</a>
</p>
</div>
<img id="logo_bottom" class="right" src="https://c.biancheng.net/templets/new/images/logo_bottom.gif" alt="底部Logo" />
<span id="return-top"><b>↑</b></span>
</div>
<div id="addweixin-widget">
<p>
<script type="text/javascript">
			/*var suffix = 'c';
			var thisMin = (new Date()).getMinutes();
			if(thisMin>=40){
				suffix = 'd';
			}else if(thisMin>=20){
				suffix = 'e';
			}else{
				suffix = 'c';
			}
			document.write('<img src="https://c.biancheng.net/templets/new/images/material/qrcode_wx_'%20+%20suffix%20+'.png?v=1.7.07" alt="微信交流群" width="120" /><br />');*/
		</script>
<img src="../templets/new/images/material/qrcode_mp_2.png" alt="微信交流群" width="120" />
<span>关注微信公众号，加入官方交流群。内含一款搜索神器，免费下载全网书籍和视频。</span>
</p>
<span id="close-addweixin-widget" class="iconfont iconfont-close"></span>
</div>
<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.7.07";

</script>
<script src="../templets/new/script/jquery1.12.4.min.js"></script>
<script src="https://c.biancheng.net/templets/new/script/common.js"></script>
<span style="display: none;">
<script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"KDf6QzBhogyQjall",ck:"KDf6QzBhogyQjall",autoTrack:true})</script>
</span>
</body>
</html>